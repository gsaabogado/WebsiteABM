[
  {
    "objectID": "01_about.html",
    "href": "01_about.html",
    "title": "About",
    "section": "",
    "text": "The website contains four primary sections to accompany the study:\n\nSOEP Data – Includes a description of all the data files of the German Socio-economic Panel Study (SOEP). It is divided into five subsections\n\n\n\nHousehold Characteristics\nTechnology Adoption\nWealth\nGallup Measures of Environmental Attitudes\n\n\n\nDescriptives SOEP – contains descriptive statistics on the SOEP Data\n\n\n\nHousehold Characteristics\nTechnology Adoption\n\n\n\nTheoretical Model – includes the mathematical description and assumptions of the model\nMathematical model – presents and discusses the python environment where we implement ABM-ren.\n\n\n\n\n\n\n\nNote\n\n\n\nConsider that all sections contain the R-code necessary to replicate the website’s figures, tables, and overall results. Regarding the construction of the data sets, we share the link to the dropbox repository alongside instructions to load the raw data files and transform them into the panel data we use for the optimization and the empirical section."
  },
  {
    "objectID": "01_about.html#raw-data-files",
    "href": "01_about.html#raw-data-files",
    "title": "About",
    "section": "Raw data files",
    "text": "Raw data files\nAs previously mentioned, the folder 01_RawData contains all the raw files. It is divided into N different repositories\n\n\n01_schools includes all files related to school absences and school characteristics in New York City\n02_AQI has the data on the air quality index forecast from the NYSDEC and the AQI measures from the EPA\n03_weather contains several data files of weather covariates\n04_shp is a repository of shape (or spatial) files\n05_dem includes data on neighbourhood-level socio-demographic characteristics from the US Census Buro"
  },
  {
    "objectID": "02_data.html",
    "href": "02_data.html",
    "title": "Data",
    "section": "",
    "text": "In this section we describe at length the main characteristics and scientific processing of the data files we use in the ABM-REN model.\nThe section is divided into three main subsections:"
  },
  {
    "objectID": "02_data.html#data-structure",
    "href": "02_data.html#data-structure",
    "title": "Data",
    "section": "Data Structure",
    "text": "Data Structure\nAll of our variables are in one of two R formats; numeric or haven-labelled. Haven labelled format is similar to STATA (or SPSS) labelled data (For more information we refer the reader to the online vignete of the haven package).\nThe R-labelled class (part of the haven package) allows us to associate arbitrary labels to numeric or character vectors. Note that the goal of labelled files is only to include the description of categorical vectors in the SOEP data. For instance, when printing one labelled variable, the output consists of a vector of values and a data frame linking values and labels.\nIt is essential to clarify that researchers must transform haven-labelled data formats into numeric or factor variables before using them in econometric, machine learning, or optimization models.\nWe keep the haven-labelled format in the raw files as it allows researchers to directly understand the values related to each numeric identifier of categorical variables in the SOEP data.\nAs an example, we show the gender-labelled variable. The ouput contains a title identifier Gender of Individual, a vector of numeric values (i.e., 2,1,2,1,1,2), and the data frame linking values to labels.\n\n\n\n\n\n<labelled<double>[6]>: Gender of Individual\n[1] 2 1 2 1 1 2\n\nLabels:\n value                                                   label\n    -8 [-8] Frage in diesem Jahr nicht Teil des Frageprogramms\n    -7 [-7] nur in weniger eingeschraenkter Edition verfuegbar\n    -6   [-6] Fragebogenversion mit geaenderter Filterfuehrung\n    -5               [-5] in Fragebogenversion nicht enthalten\n    -4                       [-4] unzulaessige Mehrfachantwort\n    -3                                  [-3] unplausibler Wert\n    -2                                    [-2] trifft nicht zu\n    -1                                       [-1] keine Angabe\n     1                                                [1] Male\n     2                                              [2] Female\n\n\nAlso note that, in general, all negative entries refer to missing values for different reasons, e.g., the question was not part of that year’s questionnaire or invalid answers."
  },
  {
    "objectID": "02_data.html#pequiv",
    "href": "02_data.html#pequiv",
    "title": "Data",
    "section": "PEQUIV",
    "text": "PEQUIV\nTable 1 shows a sample of individual-level characteristics we extract from the PEQUIV file. It consists of 18 variables and 649,099 observations between 2005 and 2018. Each variable is either in a numeric or haven-labelled format. The data frame contains the individual and household IDs (pid and hid). year refers to the year of the interview. head is an indicator variable on the relationship between pid and the household head (1 = head, 2 = partner, 3 = child, 4 = relative, and 5 = non-relative). age is the average age. sex the gender (1 - Male; 2- Female). And, education, the total years of education. Table 2 includes data on the spatial location of the household. Because we are working with the open version of the SOEP, we can only identify the state and region where the household is located.\n\nIndividualSpatialEmploymentHousehold\n\n\n\n\nShow the Code\n# Show the data set\nkbl(select(pequiv, pid, hid, year, head, sex, age, education) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 1:  Individual characteristics from the PEQUIV file \n \n  \n    pid \n    hid \n    year \n    head \n    sex \n    age \n    education \n  \n \n\n  \n    201 \n    27 \n    2005 \n    1 \n    2 \n    79 \n    10.5 \n  \n  \n    203 \n    60313 \n    2005 \n    1 \n    1 \n    45 \n    18.0 \n  \n  \n    602 \n    60 \n    2005 \n    1 \n    2 \n    47 \n    18.0 \n  \n  \n    603 \n    60 \n    2005 \n    2 \n    1 \n    59 \n    -2.0 \n  \n  \n    604 \n    60 \n    2005 \n    3 \n    1 \n    15 \n    -1.0 \n  \n  \n    605 \n    60 \n    2005 \n    3 \n    2 \n    9 \n    -1.0 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\n# Show the data set\nkbl(select(pequiv, pid, hid, year, state, region) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 2:  Spatial variables from the PEQUIV file \n \n  \n    pid \n    hid \n    year \n    state \n    region \n  \n \n\n  \n    201 \n    27 \n    2005 \n    11 \n    1 \n  \n  \n    203 \n    60313 \n    2005 \n    11 \n    1 \n  \n  \n    602 \n    60 \n    2005 \n    5 \n    1 \n  \n  \n    603 \n    60 \n    2005 \n    5 \n    1 \n  \n  \n    604 \n    60 \n    2005 \n    5 \n    1 \n  \n  \n    605 \n    60 \n    2005 \n    5 \n    1 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\n# Show the data set\nkbl(select(pequiv, pid, hid, year, employment, occupation, industry) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 3:  Employment variables from the PEQUIV file \n \n  \n    pid \n    hid \n    year \n    employment \n    occupation \n    industry \n  \n \n\n  \n    201 \n    27 \n    2005 \n    0 \n    0 \n    0 \n  \n  \n    203 \n    60313 \n    2005 \n    1 \n    2131 \n    9 \n  \n  \n    602 \n    60 \n    2005 \n    0 \n    2331 \n    9 \n  \n  \n    603 \n    60 \n    2005 \n    0 \n    -2 \n    -2 \n  \n  \n    604 \n    60 \n    2005 \n    -1 \n    -2 \n    -1 \n  \n  \n    605 \n    60 \n    2005 \n    -1 \n    -2 \n    -1 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\n# Show the data set\nkbl(select(pequiv, pid, hid, year, Npersons, Nkids, income, GrossIncome) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 4:  Household variables from the PEQUIV file \n \n  \n    pid \n    hid \n    year \n    Npersons \n    Nkids \n    income \n    GrossIncome \n  \n \n\n  \n    201 \n    27 \n    2005 \n    1 \n    0 \n    7648 \n    209 \n  \n  \n    203 \n    60313 \n    2005 \n    1 \n    0 \n    18800 \n    7550 \n  \n  \n    602 \n    60 \n    2005 \n    4 \n    2 \n    46896 \n    68132 \n  \n  \n    603 \n    60 \n    2005 \n    4 \n    2 \n    46896 \n    68132 \n  \n  \n    604 \n    60 \n    2005 \n    4 \n    2 \n    46896 \n    68132 \n  \n  \n    605 \n    60 \n    2005 \n    4 \n    2 \n    46896 \n    68132 \n  \n\n\n\n\n\n\n\n\n\nTable 3 contains employment-related covariates. employment is a dummy variable equal to one if the person is currently employed. occupation is the person’s occupation according to the International Classification of Occupations Code (ISCO). For instance, code 5,160 refers to protective service workers. industry is a two-digit industry code based on ten categories (1 – Agriculture, 2 – Energy, 3 – Mining, 4 – Manufacturing, 5 – Construction, 6 – Trade, 7 – Transport, 8 – Bank and Insurance, 9 – Services).\nTable 4 includes a set of household-level controls. While Npersons and Nkids are the number of persons and kids in the household, income and GrossIncome are the household net and gross income in Euros per year."
  },
  {
    "objectID": "02_data.html#hgen",
    "href": "02_data.html#hgen",
    "title": "Data",
    "section": "HGEN",
    "text": "HGEN\n\n\n\nTable 5 shows a sample of household-level identifiers we extract from the HGEN file. The full data-frame contains 28 variables and 252,808 observations across 47,079 households spanning between 2005 and 2018. hid and year are analogous to the pequiv file.\n\nOwner is an indicator variable based on four categories (1 – Owner, 2 – Main Tenant, 3 – Sub-Tenant, 4 – Tenant, 5 – Living in a home).\nFreeRent is a dummy variable equal to one if the family does not pay rent.\nYearMoved refers to the year the family moved to the household.\nHouseSize Is the size of the dwelling in square meters.\n\n\nHousehold IndentifiersHousehold InfrastructureHousehold EnergyHousehold Costs\n\n\n\n\nShow the Code\nkbl(select(hgen, hid, year, owner, FreeRent, YearMoved, HouseSize) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 5:  Household identifiers HGEN file \n \n  \n    hid \n    year \n    owner \n    FreeRent \n    YearMoved \n    HouseSize \n  \n \n\n  \n    27 \n    2005 \n    2 \n    -2 \n    1994 \n    43 \n  \n  \n    60 \n    2005 \n    1 \n    -2 \n    1994 \n    130 \n  \n  \n    94 \n    2005 \n    2 \n    -2 \n    2002 \n    48 \n  \n  \n    124 \n    2005 \n    2 \n    -2 \n    2002 \n    36 \n  \n  \n    159 \n    2005 \n    2 \n    1 \n    1990 \n    120 \n  \n  \n    167 \n    2005 \n    2 \n    -2 \n    2000 \n    83 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(select(hgen, hid, year, basement, garden, elevator, balcony) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 6:  Household identifiers HGEN file \n \n  \n    hid \n    year \n    basement \n    garden \n    elevator \n    balcony \n  \n \n\n  \n    27 \n    2005 \n    1 \n    2 \n    -8 \n    2 \n  \n  \n    60 \n    2005 \n    1 \n    1 \n    -8 \n    1 \n  \n  \n    94 \n    2005 \n    1 \n    2 \n    -8 \n    1 \n  \n  \n    124 \n    2005 \n    2 \n    2 \n    -8 \n    1 \n  \n  \n    159 \n    2005 \n    2 \n    2 \n    -8 \n    2 \n  \n  \n    167 \n    2005 \n    1 \n    2 \n    -8 \n    1 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(select(hgen, hid, year, CentralFloorHeating, ThermalInsulation, DoubleGlazing, AlternativeEnergy, pv, boiler) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 7:  Household energy efficiency investments \n \n  \n    hid \n    year \n    CentralFloorHeating \n    ThermalInsulation \n    DoubleGlazing \n    AlternativeEnergy \n    pv \n    boiler \n  \n \n\n  \n    27 \n    2005 \n    1 \n    -8 \n    -8 \n    -8 \n    -8 \n    1 \n  \n  \n    60 \n    2005 \n    1 \n    -8 \n    -8 \n    -8 \n    -8 \n    1 \n  \n  \n    94 \n    2005 \n    1 \n    -8 \n    -8 \n    -8 \n    -8 \n    1 \n  \n  \n    124 \n    2005 \n    1 \n    -8 \n    -8 \n    -8 \n    -8 \n    1 \n  \n  \n    159 \n    2005 \n    1 \n    -8 \n    -8 \n    -8 \n    -8 \n    1 \n  \n  \n    167 \n    2005 \n    1 \n    -8 \n    -8 \n    -8 \n    -8 \n    1 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(select(hgen, hid, year, PowerCosts, OtherUtilityCosts, GasCosts, WarmWaterCosts) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 8:  Household energy costs \n \n  \n    hid \n    year \n    PowerCosts \n    OtherUtilityCosts \n    GasCosts \n    WarmWaterCosts \n  \n \n\n  \n    27 \n    2005 \n    -8 \n    20 \n    -5 \n    30 \n  \n  \n    60 \n    2005 \n    -8 \n    -2 \n    -5 \n    -2 \n  \n  \n    94 \n    2005 \n    -8 \n    77 \n    -5 \n    49 \n  \n  \n    124 \n    2005 \n    -8 \n    150 \n    -5 \n    40 \n  \n  \n    159 \n    2005 \n    -8 \n    -1 \n    -5 \n    -1 \n  \n  \n    167 \n    2005 \n    -8 \n    60 \n    -5 \n    5 \n  \n\n\n\n\n\n\n\n\n\nTable 6 contains different infrastructure characteristics of the dwelling. All variables are indicator dummies of basement, garden, elevator, or balcony infrastructure.\nTable 7 includes a set of indicator variables regarding household investments in Energy infrastructure or appliances. The indicator variables come from answers to the question What amenities does your dwelling have? Does it have - central floor heating (CentralFloorHeating - 1984-2014), floor heating (FloorHeating - since 2014), thermal insulation in the facade, roof, or basement (ThermalInsulation - Since 2015), air conditioner (ac - Since 2007), solar energy system (pv - Since 2007), other alternative energy sources like geothermal or heat pump (AlternativeEnergy - Since 2009), boiler (boiler - 1991-2013), or windows with at least double glazing (DoubleGlazing - Since 2015).\nTable 8 includes a set of numeric variables on the household’s energy costs:\n\nWarmWaterCost: contains the heating costs of tenants. The number comes from answers to the question What were the heating costs, including hot water, in the last calendar year?. Until 2013 (wave BD), the SOEP only surveyed heating costs for tenants. After 2013, it asked all SOEP individuals. In 2015 (wave BF), respondents stated their costs for different energy sources (district heating, gas, liquefied gas, electricity, heating oil, coal, wood, biomass, solar, and geothermal) and whether they used them for heating, warm water, cooking, or electronic devices. This change decreased the WarmWaterCost variable in the BF wave vs. other years.\nPowerCosts: is a numeric variable with the electricity costs (excluding heating when applicable) asked since 2010. The exact questionnaire question is; What were your electricity costs in the last calendar year? The SOEP only asks this question to tenants if they pay rent. However, from 2016, it asked all tenants whether they paid rent or not.\nGasCosts: states the monthly costs of gas not used for heating in Euros. Gas costs were only collected in 2014 (wave BE).\nOtherUtilityCosts: are answers to the question; how much did you pay in the last calendar year for water, garbage removal, street cleaning, and other additional costs not mentioned above?"
  },
  {
    "objectID": "02_data.html#hconsum",
    "href": "02_data.html#hconsum",
    "title": "Data",
    "section": "HCONSUM",
    "text": "HCONSUM\n\nIntroduction\nWe use the 2010 SOEP consumption module to estimate the consumption propensity of German households. The SOEP consumption module, or “hconsum,” was implemented as part of the 31st SOEP wave in 2010. The goal of hconsum is to allow researchers to understand the relationship between welfare, income, and disposable income – whereas consumption characterizes the actual current living standard, income describes the potential command over resources. For a complete review of the SOEP consumption module, we refer the reader to Marcus, Siegers, and Grabka (2013). In this chapter, we only highlight the its main characteristics.\nUsually, consumption data takes one of two forms; consumption journals or representative surveys. The goal of consumption journals is to keep track of all daily expenditures across a cross-section of representative households to understand consumption patterns. Once there is enough data, researchers aggregate the items into categories to assess the main components of households’ income use. . Representative surveys, on the other hand, study typical consumption instead of consumption at a given time. The core idea is that asking for a relevant set of common consumption goods can act as a good proxy for total consumption.\nIn the 2010 hconsum module, the SOEP adopted the idea of consumption goods to approximate total consumption. In total, they collected twenty-four different consumption categories spanning from food expenditures to insurance costs.\nThere were a series of methodological challenges while collecting the consumption data. First, there were inconsistencies between reported monthly and yearly expenditures. In total, the share of inconsistencies is smaller than one percent. Next, there were missing values (usually around 2-4%) across several categories. Finally, there was clear evidence of heaping (coarse reporting of continuous values).\nThe SOEP solves the inconsistency between monthly and yearly data with the following process. First, it computes the percentiles of consumption according to the reported monthly and annual values. Second, compare this percentage rank to the percentiles of the household net income. In case of inconsistent monthly and yearly information, the SOEP assigns the consumption value of the category whose percentile is the closest to the income distribution.\nFor missing data, the SOEP uses multiple imputation methods. However, instead of assigning only one value per income category, the SOEP assign five different values to reflect the uncertainty in the imputation process. Particularly, the SOEP impute the missing values through multivariate imputation by chained equations (MICE) (Van Buuren, Boshuizen, and Knook 1999).\nFor heaping, the SOEP adjust the heaped data by approximating its true distribution with an theoretical distribution of consumption behaviour. After several theoretical exercise, the SOEP chooses the gamma and generalized beta distribution of the second kind (GB2) to approximate the true distribution of consumption data. Equation 1 contains the mathematical formula behind the GB2 distribution. In it, \\(x\\) is consumption, \\(B(b,q)\\) the beta function, and a,b,p, and q positive parameters.\n\\[\nf(x) = ax^{ap-1}\\Big[b^{ab} B(p,q)\\Big(1 + (\\frac{x}{b})^a\\Big)^{p+q}\\Big]^{-1}\n\\tag{1}\\]\n\n\n\nIn Table 9, we show a sample of the consumption data for daily expenditures. Table 10 contains a similar exercise for housing costs, Table 11 for financial burdens, and Table 12 for other income uses. All values are in thousand of Euros per year and come from averaging the five different imputations of the SOEP consumption module across categories.\n\nDaily ExpendituresHousing expendituresFinancial expendituresOther expenditures\n\n\n\n\nShow the Code\nkbl(data |> select(hid, Food, Clothes, Transport, Coms, Leisure, Cleaning) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 9:  Sample of the consumption module (daily expenditures) \n \n  \n    hid \n    Food \n    Clothes \n    Transport \n    Coms \n    Leisure \n    Cleaning \n  \n \n\n  \n    60 \n    6.870 \n    1.431 \n    1.1055 \n    0.711 \n    2.0010 \n    0.00 \n  \n  \n    94 \n    3.606 \n    0.645 \n    0.3375 \n    0.528 \n    0.2745 \n    0.00 \n  \n  \n    159 \n    2.580 \n    0.792 \n    0.6990 \n    0.123 \n    1.5705 \n    2.40 \n  \n  \n    167 \n    3.576 \n    0.000 \n    1.1790 \n    0.870 \n    0.0000 \n    0.00 \n  \n  \n    230 \n    6.135 \n    0.429 \n    1.5000 \n    0.726 \n    0.7605 \n    2.40 \n  \n  \n    477 \n    0.000 \n    0.000 \n    0.1155 \n    0.000 \n    0.0000 \n    0.72 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(data |> select(hid, Rent, Mortgage, Housing, Heating, Power, Utilities, Furniture) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 10:  Sample of the consumption module (Housing) \n \n  \n    hid \n    Rent \n    Mortgage \n    Housing \n    Heating \n    Power \n    Utilities \n    Furniture \n  \n \n\n  \n    60 \n    4.908 \n    16.32 \n    0 \n    1.500 \n    1.1500 \n    1.0 \n    0.036 \n  \n  \n    94 \n    5.592 \n    0.00 \n    0 \n    0.576 \n    0.6100 \n    0.6 \n    0.000 \n  \n  \n    159 \n    0.000 \n    0.00 \n    0 \n    1.530 \n    0.7255 \n    0.6 \n    0.000 \n  \n  \n    167 \n    3.684 \n    0.00 \n    0 \n    1.104 \n    0.7780 \n    0.6 \n    0.000 \n  \n  \n    230 \n    4.908 \n    7.44 \n    0 \n    1.100 \n    0.5250 \n    0.5 \n    0.318 \n  \n  \n    477 \n    6.252 \n    0.00 \n    0 \n    0.948 \n    0.8200 \n    0.6 \n    0.000 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(data |> select(hid, Insurance, Loans, Mortgage) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 11:  Sample of the consumption module (Housing) \n \n  \n    hid \n    Insurance \n    Loans \n    Mortgage \n  \n \n\n  \n    60 \n    3.5280 \n    0.00 \n    16.32 \n  \n  \n    94 \n    0.9825 \n    0.72 \n    0.00 \n  \n  \n    159 \n    7.2255 \n    0.00 \n    0.00 \n  \n  \n    167 \n    1.3110 \n    0.00 \n    0.00 \n  \n  \n    230 \n    0.3990 \n    0.00 \n    7.44 \n  \n  \n    477 \n    0.0060 \n    0.00 \n    0.00 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(data |> select(hid, Alimony, ChildCare, Culture, Education, Health, Holidays, Other) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 12:  Sample of the consumption module (Other) \n \n  \n    hid \n    Alimony \n    ChildCare \n    Culture \n    Education \n    Health \n    Holidays \n    Other \n  \n \n\n  \n    60 \n    0 \n    0.96 \n    0.441 \n    0.201 \n    0.9000 \n    5.772 \n    0.402 \n  \n  \n    94 \n    0 \n    0.00 \n    0.054 \n    0.000 \n    0.3255 \n    0.000 \n    0.000 \n  \n  \n    159 \n    0 \n    0.00 \n    0.096 \n    0.000 \n    0.3465 \n    2.304 \n    0.000 \n  \n  \n    167 \n    0 \n    0.00 \n    0.000 \n    0.000 \n    0.6345 \n    0.000 \n    0.141 \n  \n  \n    230 \n    0 \n    0.00 \n    0.438 \n    0.126 \n    0.1860 \n    4.104 \n    0.699 \n  \n  \n    477 \n    0 \n    0.00 \n    0.000 \n    0.000 \n    0.5295 \n    0.000 \n    0.000 \n  \n\n\n\n\n\n\n\n\n\nIn Figure 2, we look at the difference in consumption values and composition across the SOEP income deciles. For this, we aggregate all consumption items into eight categories; Daily expenditures, health, financial, transport, heating, power, housing, and others. There are apparent differences in the amount of money used for consumption across income groups. For instance, in the highest and lowest deciles of the income distribution, households spend 14,900 and 4,460 Euros per year, respectively. Figure 2 portrays a clearer picture of the composition of these expenditures across income groups. While the share of financial and health costs grows with income, heating and power expenditures decrease. Figure 3 clearly shows these trends with a heat map of consumption category by income decile. The expenditure share of housing, daily expenses, and health remains relatively stable; financial, transport and health costs increase with income; and heating-power expenses decrease. In Figure 4, we plot the ratio of average income to consumption by income decile. As expected, the consumption income ratio drops as we become more well-off. In the lowest income decile, families spend, on average, 34% more than their average income, meaning that they either live from debt or receive additional and unreported income from other sources. Once we move to the second income decile, the ratio reaches parity and implies that persons in this decile earn as much as they spend. Finally, in Figure 5, we plot the heat map of consumption income ratios across different categories.\n\n\nDescriptives\n\nConsumptionCon. ShareCon. MatrixCon/IncomeCon/Income matrix\n\n\n\n\nShow the Code\n# Divide into income deciles \ndata = mutate(data, decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Create the data for the plot\nplot= select(data, -total, -income, -owner) %>% \n  gather(var, value, -hid, -decile)%>% \n  left_join(., codebook, by = c(\"var\" = \"concept\")) |> \n  group_by(decile, group) |> \n  summarise(value = mean(value)) |> \n  mutate(group = fct_reorder(factor(group), value, .desc = F)) |> \n  group_by(decile) |> mutate(total = sum(value))\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_bar(aes(x = decile, y = value, fill = group), stat = \"identity\") +\n  scale_fill_viridis(discrete = T, option = \"E\") +\n  theme_economist() %+replace% theme(legend.title = element_blank()) +\n  labs(x = \"Income Decile\", y = \"\")\n\n\n\n\n\nFigure 1: Yearly consumption by concept in thousand euros (SOEP 2010)\n\n\n\n\n\n\n\n\nShow the Code\n# Divide into income deciles \ndata = mutate(data, decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Create the data for the plot\nplot = select(data, -total, -income, -owner) %>% \n  gather(var, value, -hid, -decile) %>% \n  left_join(., codebook, by = c(\"var\" = \"concept\")) |> group_by(decile, group) |> \n  summarise(value = mean(value)) |> group_by(decile) |> \n  mutate(share = (value/sum(value))*100)  |> \n  mutate(group = fct_reorder(factor(group), share, .desc = F))\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_bar(aes(x = decile, y = share, fill = group), stat = \"identity\") +\n  scale_fill_viridis(discrete = T, option = \"E\") +\n  theme_economist() %+replace% theme(legend.title = element_blank()) +\n  labs(x = \"\", y = \"\")\n\n\n\n\n\nFigure 2: Consumption share by concept (SOEP 2010)\n\n\n\n\n\n\n\n\nShow the Code\n# Divide into income deciles \ndata = mutate(data, decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Create the data for the plot\nplot = select(data, -total, -income, -owner) %>% \n  gather(var, value, -hid, -decile) %>% \n  left_join(., codebook, by = c(\"var\" = \"concept\")) |> group_by(decile, group) |> \n  summarise(value = mean(value)) |> group_by(decile) |> \n  mutate(share = (value/sum(value))*100)  |> \n  mutate(group = fct_reorder(factor(group), share, .desc = F))\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_tile(aes(x = decile, y = group, fill = share), alpha = 0.75) +\n  geom_text(aes(x = decile, y = group, label = paste0(round(share, 1), \"%\"))) +\n  scale_fill_viridis(discrete = F, begin = 0, end = 0.6, option = \"D\") +\n  theme_economist() %+replace% theme(legend.title = element_blank()) +\n  labs(x = \"\", y = \"\") + guides(fill = \"none\")\n\n\n\n\n\nFigure 3: Share of total consumption across categories\n\n\n\n\n\n\n\n\nShow the Code\n# Divide into income deciles \ndata = mutate(data, decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Create the data for the plot\nplot = select(data, total, income, decile) |> \n  group_by(decile) |> \n  summarise(consumption = mean(total), income = mean(income)) |> \n  mutate(share = (consumption/income)*100)\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_bar(aes(x = decile, y = share, fill = share), stat = \"identity\") +\n  geom_text(aes(x = decile, y = share, label = paste0(round(share,1), \"%\")), vjust = -0.5) +\n  scale_fill_viridis(discrete = F, option = \"E\", direction = -1) +\n  theme_economist() + guides(fill = \"none\") +\n  labs(x = \"\", y = \"\")  \n\n\n\n\n\nFigure 4: Consumption share of income (SOEP 2010)\n\n\n\n\n\n\n\n\nShow the Code\n# Divide into income deciles \ndata = mutate(data, decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Create the data for the plot\nplot = select(data, -total, -owner) %>% \n  gather(var, value, -hid, -decile, -income) %>% \n  left_join(., codebook, by = c(\"var\" = \"concept\")) |> group_by(decile, group, var) |> \n  summarise(value = mean(value, na.rm = T), income = mean(income, na.rm = T)) |> \n  group_by(decile, group, income) |> summarise(total = sum(value)) |> group_by(decile, group) |> \n  mutate(share = (total/income)*100)  |> \n  mutate(group = fct_reorder(factor(group), total, .desc = T))\n\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_tile(aes(x = decile, y = reorder(group, share), fill = share), alpha = 0.75) +\n  geom_text(aes(x = decile, y = group, label = paste0(round(share, 1), \"%\"))) +\n  scale_fill_viridis(discrete = F, begin = 0, end = 0.6, option = \"D\") +\n  theme_economist() %+replace% theme(legend.title = element_blank()) +\n  labs(x = \"\", y = \"\") + guides(fill = \"none\")\n\n\n\n\n\nFigure 5: Consumption share of income across categories"
  },
  {
    "objectID": "02_data.html#hwealth",
    "href": "02_data.html#hwealth",
    "title": "Data",
    "section": "HWEALTH",
    "text": "HWEALTH\n\nIntroduction\nThe SOEP collected wealth data in 2002, 2007, 2012, and 2017 through the HWEALTH module.\nCompared to pure demographic variables, wealth data often contains high nonresponse rates. The SOEP adjusts for missing data with logical and multiple imputations. In 2002, the SOEP surveyed nine asset and liability components; owner-occupied housing, other property, financial assets, business assets, tangible assets, private pensions, mortgage debts, and consumer credits. While in 2002, the Item private pensions and life insurances included building loan contracts, the SOEP separated the question from 2007. In 2017, the SOEP added two wealth components, the value of vehicles and student loans. However, other assets are missing, e.g., cash, livestock and crops, equipment, intangible assets, claims against private insurance, and commercial loans.\nTable 13 contains a sample of the HWEALTH module aggregate wealth measures. These are, GrossWealth GrossDebts, and NetWealth. For each element, there are two distinct columns. The column with the number two at the end corresponds to wealth values considering vehicles and student loans. The one without the suffix only considers the wealth of the nine assets surveyed since 2002.\nTable 14 shows a sample of property wealth. While the column without the number two at the end corresponds to owner-occupied housing, the column with a two at the end refers to other properties. As with the previous table, it is possible to separate property values into gross, debt, and net.\n\n\n\n\nTotal WealthPropertiesFinancialOther\n\n\n\n\nShow the Code\nkbl(data |> select(c(hid, year, GrossWealth:NetWealth2)) %>% arrange(-year, hid) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 13:  Sample of the wealth module (Totals) \n \n  \n    hid \n    year \n    GrossWealth \n    GrossWealth2 \n    GrossDebts \n    GrossDebts2 \n    NetWealth \n    NetWealth2 \n  \n \n\n  \n    94 \n    2017 \n    103000 \n    103000 \n    0 \n    0 \n    103000 \n    103000 \n  \n  \n    159 \n    2017 \n    1139800 \n    1143800 \n    0 \n    0 \n    1139800 \n    1143800 \n  \n  \n    167 \n    2017 \n    20000 \n    23000 \n    0 \n    0 \n    20000 \n    23000 \n  \n  \n    230 \n    2017 \n    404000 \n    409000 \n    0 \n    0 \n    404000 \n    409000 \n  \n  \n    523 \n    2017 \n    51000 \n    69000 \n    0 \n    0 \n    51000 \n    69000 \n  \n  \n    582 \n    2017 \n    5000 \n    5000 \n    0 \n    0 \n    5000 \n    5000 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(data |> select(c(hid, year, HouseRaw:HouseDebt2)) %>% arrange(-year, hid) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 14:  Sample of the wealth module (Properties) \n \n  \n    hid \n    year \n    HouseRaw \n    HouseDebt \n    HouseNet \n    HouseRaw2 \n    HouseNet2 \n    HouseDebt2 \n  \n \n\n  \n    94 \n    2017 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n  \n  \n    159 \n    2017 \n    0 \n    0 \n    0 \n    1500 \n    1500 \n    0 \n  \n  \n    167 \n    2017 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n  \n  \n    230 \n    2017 \n    350000 \n    0 \n    350000 \n    0 \n    0 \n    0 \n  \n  \n    523 \n    2017 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n  \n  \n    582 \n    2017 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(data |> select(c(hid, year, financial, insurances, ConsumerDebt, StudentLoans)) %>% arrange(-year, hid) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 15:  Sample of the wealth module (Financial) \n \n  \n    hid \n    year \n    financial \n    insurances \n    ConsumerDebt \n    StudentLoans \n  \n \n\n  \n    94 \n    2017 \n    3000 \n    200000 \n    0 \n    0 \n  \n  \n    159 \n    2017 \n    1000000 \n    51800 \n    0 \n    0 \n  \n  \n    167 \n    2017 \n    0 \n    40000 \n    0 \n    0 \n  \n  \n    230 \n    2017 \n    50000 \n    4000 \n    0 \n    0 \n  \n  \n    523 \n    2017 \n    45000 \n    12000 \n    0 \n    0 \n  \n  \n    582 \n    2017 \n    0 \n    10000 \n    0 \n    0 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(data |> select(c(hid, year, tangible, business, CarsValue)) %>% arrange(-year, hid) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 16:  Sample of the wealth module (Other) \n \n  \n    hid \n    year \n    tangible \n    business \n    CarsValue \n  \n \n\n  \n    94 \n    2017 \n    0 \n    0 \n    0 \n  \n  \n    159 \n    2017 \n    10000 \n    102400 \n    4000 \n  \n  \n    167 \n    2017 \n    0 \n    0 \n    3000 \n  \n  \n    230 \n    2017 \n    0 \n    0 \n    5000 \n  \n  \n    523 \n    2017 \n    0 \n    0 \n    18000 \n  \n  \n    582 \n    2017 \n    0 \n    0 \n    0 \n  \n\n\n\n\n\n\n\n\n\nTable 15 includes financial wealth in the form of financial assets, insurances, consumer debt, and car loans. Table 16 further portrays other wealth elements as the value of business, vehicles, and tangible assets\nFigure 6 portrays the relationshipo between the income distribution divided by deciles and gross wealth, gross debt, and net wealth. As expected, both wealth and debts increase with income. While, average net wealth for the highest decile is of more than 805,000 Euros (118k of debt) , net wealth for the lowest decile is less than 17,000 euros (2.5k of debt). Figure 7 shows the same relationship for age, in line with the literature, age and wealth exhibit decreasing returns to scale (add cite). Although debts peak for people between 40 and 50, Gross and Net Wealth peak for people between 60 and 70.\nIn Figure 8 we show the composition of wealth by income decile. The overall wealth structure seems quite constant between the first and ninth deciles. However, for the last decile, the wealth composition changes by increasing the importance of business and other properties as a share of total wealth.\n\n\nDescriptives\n\nWealth and IncomeWealth and AgeWealth Composition\n\n\n\n\nShow the Code\n# Create the data for the plot\ndata = mutate(ungroup(data), decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Plot \nplot = data |> filter(year == 2017) |> \n  select(decile, `A) Gross Wealth`= GrossWealth, `B) Gross Debt` = GrossDebts, \n         `C) Net Wealth` = NetWealth) %>%\n  gather(var, value, -decile) %>%  group_by(decile, var) |> \n  summarise(value = mean(value))\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_bar(aes(x = decile, y = value/1000, fill = decile), stat = \"identity\") +\n  scale_fill_viridis(discrete = T, option = \"E\") +\n  theme_economist() %+replace% theme(legend.title = element_blank()) +\n  labs(x = \"\", y = \"\") + facet_wrap(~var) + guides(fill = \"none\")\n\n\n\n\n\nFigure 6: Relationship between income and total wealth\n\n\n\n\n\n\n\n\nShow the Code\n# Create the data for the plot\ndata = mutate(ungroup(data), decile = cut2(age, seq(10, 80, 10))) |> \n  mutate(decile = as_factor(decile))\n# Plot \nplot = data |> filter(year == 2017) |> \n  select(decile, `A) Gross Wealth`= GrossWealth, `B) Gross Debt` = GrossDebts, \n         `C) Net Wealth` = NetWealth) %>%\n  gather(var, value, -decile) %>%  group_by(decile, var) |> \n  summarise(value = mean(value))\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_bar(aes(x = decile, y = value/1000, fill = decile), stat = \"identity\") +\n  scale_fill_viridis(discrete = T, option = \"E\") +\n  theme_economist() %+replace% theme(legend.title = element_blank(), axis.text.x = element_text(angle = 90)) +\n  labs(x = \"\", y = \"\") + facet_wrap(~var) + guides(fill = \"none\")\n\n\n\n\n\nFigure 7: Relationship betsween age and total wealth\n\n\n\n\n\n\n\n\nShow the Code\ndata = mutate(ungroup(data), decile = ntile(income, 10)) |> \n  mutate(decile = as_factor(decile))\n# Create the data for the plot\nplot = data |>  filter(year == 2017) |> \n  select(-c(GrossWealth:NetWealth2, HouseRaw, age, year, \n            HouseRaw2, HouseDebt, HouseDebt2, \n            ConsumerDebt, StudentLoans, income)) %>%  \n  gather(var, value, -hid, -decile) |> group_by(decile, var) |> \n  summarise(value = mean(value)/1000) |> group_by(decile) |> \n  mutate(share = (value/sum(value))*100)  \n# Rename the wealth groups\norig = c(\"tangible\", \"business\", \"CarsValue\", \"HouseNet2\", \"insurances\", \"financial\", \"HouseNet\")\nsubs = c(\"Tangible\", \"Business\", \"Cars\",\n         \"Other Property\", \"Insurance\", \"Financial\", \"Main Property\")\nplot = mutate(plot, group = mgsub(var, orig, subs)) |> \n  mutate(group = fct_reorder(factor(group), share, .desc = F))\n# Transform from wide to long format \nplot = gather(plot, type, value, -decile, -var, -group) |> \n  mutate(type = mgsub(type, c(\"value\", \"share\"), c(\"a) Value in Ths. Euros\", \"b) Percentage of Net Wealth\")))|> \n  mutate(group = fct_reorder(factor(group), value, .desc = F))\n# Plot total expenditures by concept\nggplot(plot) +\n  geom_bar(aes(x = decile, y = value, fill = str_wrap(group, 15)), stat = \"identity\") +\n  scale_fill_viridis(discrete = T, option = \"E\") +\n  theme_economist() %+replace% \n  theme(legend.title = element_blank(), strip.text = element_text(hjust = 0)) +\n  labs(x = \"\", y = \"\") + facet_wrap(~type, scales = \"free\")\n\n\n\n\n\nFigure 8: Composition of wealth by income decile"
  },
  {
    "objectID": "02_data.html#individual-panel",
    "href": "02_data.html#individual-panel",
    "title": "Data",
    "section": "Individual panel",
    "text": "Individual panel\n\n\n\nOnce we load the hgen and pequiv files, we merge them and construct a final panel data of SOEP individuals between 2005 and 2018. The data set contains 649,099 observations across 128,200 individuals and 47,079 households. On average, each person remains in the panel 5.1 years. The data set contains 57 different variables (each of which is defined in the glossary section).\nWhen merging the household and individual-level data. We perform different checks and create additional variables.\n\nChange all missing values from the SOEP formating to R NA format.\nTransform the indicator variables with “Ja” or “Nein” structure to binary dummies.\nTransform net and gross income (income, GrossIncome) from Euros to Thousand of Euros.\nImpute the ownership and lodge indicators in cases with missing data if the household does not report moving.\nAssume that if the dwelling has a garden it is a house.\nAssume that if the dwelling has an elevator it is a flat.\nTransform the PV data from one when bought to one if owned.\nDetermine the age of the panel – PanelYear.\nSimplify the lodge identifier to only “House” or “Flat”.\n\nTable 17 to Table 22 contain samples of the final individual-evel data across different sets of variables. For instance, Table 17 shows a sample of the individual-level characteristics, YearMoved, head, age, sex, and education.\n\nIndividual covariatesEmploymentDwellingEnergy EfficiencyEnergy Costs\n\n\n\n\nShow the Code\nkbl(soep |> select(pid, hid, year, YearMoved, head, age, sex, education) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 17:  Individual Covariates in the full sample \n \n  \n    pid \n    hid \n    year \n    YearMoved \n    head \n    age \n    sex \n    education \n  \n \n\n  \n    201 \n    27 \n    2005 \n    1994 \n    2 \n    79 \n    2 \n    10.5 \n  \n  \n    201 \n    27 \n    2006 \n    1994 \n    2 \n    80 \n    2 \n    10.5 \n  \n  \n    201 \n    27 \n    2007 \n    1994 \n    2 \n    81 \n    2 \n    10.5 \n  \n  \n    201 \n    27 \n    2008 \n    1994 \n    2 \n    82 \n    2 \n    10.5 \n  \n  \n    203 \n    60313 \n    2005 \n    1997 \n    2 \n    45 \n    1 \n    18.0 \n  \n  \n    203 \n    60313 \n    2006 \n    1997 \n    2 \n    46 \n    1 \n    18.0 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(soep |> select(pid, hid, year, employment, occupation, income, GrossIncome) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 18:  Employmenr Covariates in the full sample \n \n  \n    pid \n    hid \n    year \n    employment \n    occupation \n    income \n    GrossIncome \n  \n \n\n  \n    201 \n    27 \n    2005 \n    0 \n    0 \n    7.648 \n    0.209 \n  \n  \n    201 \n    27 \n    2006 \n    0 \n    0 \n    7.723 \n    0.301 \n  \n  \n    201 \n    27 \n    2007 \n    0 \n    0 \n    11.488 \n    4.103 \n  \n  \n    201 \n    27 \n    2008 \n    0 \n    0 \n    8.019 \n    0.209 \n  \n  \n    203 \n    60313 \n    2005 \n    1 \n    2131 \n    18.800 \n    7.550 \n  \n  \n    203 \n    60313 \n    2006 \n    1 \n    2131 \n    24.796 \n    28.900 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(ungroup(soep) |> select(pid, hid, year, owner, FreeRent, lodge, NewestConstDate, OldestConstDate) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 19:  Employmenr Covariates in the full sample \n \n  \n    pid \n    hid \n    year \n    owner \n    FreeRent \n    lodge \n    NewestConstDate \n    OldestConstDate \n  \n \n\n  \n    201 \n    27 \n    2005 \n    0 \n    NA \n    Flats \n    1980 \n    1972 \n  \n  \n    201 \n    27 \n    2006 \n    0 \n    NA \n    Flats \n    1980 \n    1972 \n  \n  \n    201 \n    27 \n    2007 \n    0 \n    NA \n    Flats \n    1980 \n    1972 \n  \n  \n    201 \n    27 \n    2008 \n    0 \n    NA \n    Flats \n    1980 \n    1972 \n  \n  \n    203 \n    60313 \n    2005 \n    0 \n    NA \n    Flats \n    1918 \n    0 \n  \n  \n    203 \n    60313 \n    2006 \n    0 \n    NA \n    Flats \n    1918 \n    0 \n  \n\n\n\n\n\n\n\nDwelling Charac.\n\n\nShow the Code\nkbl(ungroup(soep) |> select(pid, hid, year, HouseSize, basement, garden, elevator, balcony) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 20:  Dwelling characteristics Covariates in the full sample \n \n  \n    pid \n    hid \n    year \n    HouseSize \n    basement \n    garden \n    elevator \n    balcony \n  \n \n\n  \n    201 \n    27 \n    2005 \n    43 \n    1 \n    0 \n    -8 \n    0 \n  \n  \n    201 \n    27 \n    2006 \n    43 \n    1 \n    0 \n    -8 \n    0 \n  \n  \n    201 \n    27 \n    2007 \n    43 \n    0 \n    0 \n    -8 \n    1 \n  \n  \n    201 \n    27 \n    2008 \n    43 \n    1 \n    0 \n    -8 \n    1 \n  \n  \n    203 \n    60313 \n    2005 \n    67 \n    1 \n    0 \n    -8 \n    1 \n  \n  \n    203 \n    60313 \n    2006 \n    67 \n    1 \n    0 \n    -8 \n    1 \n  \n\n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(ungroup(soep) |> select(pid, hid, year, ac, FloorHeating, CentralFloorHeating, ThermalInsulation, AlternativeEnergy, pv, boiler) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 21:  Energy Efficiency Technologies \n \n  \n    pid \n    hid \n    year \n    ac \n    FloorHeating \n    CentralFloorHeating \n    ThermalInsulation \n    AlternativeEnergy \n    pv \n    boiler \n  \n \n\n  \n    201 \n    27 \n    2005 \n    NA \n    -8 \n    1 \n    -8 \n    -8 \n    0 \n    1 \n  \n  \n    201 \n    27 \n    2006 \n    NA \n    -8 \n    1 \n    -8 \n    -8 \n    0 \n    1 \n  \n  \n    201 \n    27 \n    2007 \n    0 \n    -8 \n    1 \n    -8 \n    -8 \n    0 \n    1 \n  \n  \n    201 \n    27 \n    2008 \n    0 \n    -8 \n    1 \n    -8 \n    -8 \n    0 \n    1 \n  \n  \n    203 \n    60313 \n    2005 \n    NA \n    -8 \n    1 \n    -8 \n    -8 \n    0 \n    1 \n  \n  \n    203 \n    60313 \n    2006 \n    NA \n    -8 \n    1 \n    -8 \n    -8 \n    0 \n    1 \n  \n\n\n\n\n\n\n\n\n\n\nShow the Code\nkbl(ungroup(soep) |> select(pid, hid, year, PowerCosts, OtherUtilityCosts, GasCosts, WarmWaterCosts) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 22:  Energy Efficiency Technologies \n \n  \n    pid \n    hid \n    year \n    PowerCosts \n    OtherUtilityCosts \n    GasCosts \n    WarmWaterCosts \n  \n \n\n  \n    201 \n    27 \n    2005 \n    NA \n    20 \n    NA \n    30 \n  \n  \n    201 \n    27 \n    2006 \n    NA \n    20 \n    NA \n    33 \n  \n  \n    201 \n    27 \n    2007 \n    NA \n    25 \n    NA \n    30 \n  \n  \n    201 \n    27 \n    2008 \n    NA \n    20 \n    NA \n    30 \n  \n  \n    203 \n    60313 \n    2005 \n    NA \n    40 \n    NA \n    20 \n  \n  \n    203 \n    60313 \n    2006 \n    NA \n    75 \n    NA \n    20"
  },
  {
    "objectID": "02_data.html#dwelling-charac.",
    "href": "02_data.html#dwelling-charac.",
    "title": "Data",
    "section": "Dwelling Charac.",
    "text": "Dwelling Charac.\n\n\nShow the Code\nkbl(ungroup(soep) |> select(pid, hid, year, HouseSize, basement, garden, elevator, balcony) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 20:  Dwelling characteristics Covariates in the full sample \n \n  \n    pid \n    hid \n    year \n    HouseSize \n    basement \n    garden \n    elevator \n    balcony \n  \n \n\n  \n    201 \n    27 \n    2005 \n    43 \n    1 \n    0 \n    -8 \n    0 \n  \n  \n    201 \n    27 \n    2006 \n    43 \n    1 \n    0 \n    -8 \n    0 \n  \n  \n    201 \n    27 \n    2007 \n    43 \n    0 \n    0 \n    -8 \n    1 \n  \n  \n    201 \n    27 \n    2008 \n    43 \n    1 \n    0 \n    -8 \n    1 \n  \n  \n    203 \n    60313 \n    2005 \n    67 \n    1 \n    0 \n    -8 \n    1 \n  \n  \n    203 \n    60313 \n    2006 \n    67 \n    1 \n    0 \n    -8 \n    1"
  },
  {
    "objectID": "02_data.html#distribution-of-power-costs-by-income",
    "href": "02_data.html#distribution-of-power-costs-by-income",
    "title": "Data",
    "section": "Distribution of power costs by income",
    "text": "Distribution of power costs by income\nNext, we use the information on income and power cost from the sub-set of renters to look at the relationship between annual power costs and income. For this, we divide the data set into ten different income groups based on the deciles of the income distribution and estimate the average and standard deviation of income and power costs in each decile.\nTable 23 contains a sample of the final data. IncomeGroup refers to the income decile. IncAvg is the average yearly income in thousands of Euros. PowerCostAvg is the average yearly power bill in Euros. IncSD is the standard deviation of annual income. And PowerCostSd the analogous for power costs. Figure 9 contains the density (Log) function of annual Power Costs across different income deciles. As expected, the density is normally distributed with higher mean values for more wealthy households.\n\nData SetDescriptives\n\n\n\n\nShow the Code\n# Load Data\nfile = gsub(\"WebsiteABM\", \"\", getwd())\ndata = read_rds(paste0(file, \"02_GenData/03_SoepFiles/IncomePowerDeciles.rds\"))\n# Show the table\nkbl(ungroup(data) %>% head(.)) %>% \n  kable_classic(full_width = T, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 23:  Energy Efficiency Technologies \n \n  \n    IncomeGroup \n    year \n    IncAvg \n    PowerCostAvg \n    IncSd \n    PowerCostSd \n  \n \n\n  \n    [ 0.0, 12.0) \n    2010 \n    9.474033 \n    528.6613 \n    1.591792 \n    271.8127 \n  \n  \n    [ 0.0, 12.0) \n    2017 \n    9.445816 \n    578.1282 \n    1.603025 \n    306.3380 \n  \n  \n    [12.0, 17.0) \n    2010 \n    14.628578 \n    609.2459 \n    1.416789 \n    336.8479 \n  \n  \n    [12.0, 17.0) \n    2017 \n    14.640152 \n    656.0660 \n    1.423581 \n    337.2172 \n  \n  \n    [17.0, 21.5) \n    2010 \n    19.256240 \n    664.0950 \n    1.294342 \n    324.0003 \n  \n  \n    [17.0, 21.5) \n    2017 \n    19.264616 \n    683.9172 \n    1.292820 \n    335.5565 \n  \n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Density function of Power Costs across Income Deciles"
  },
  {
    "objectID": "02_data.html#share-of-pv-adoption",
    "href": "02_data.html#share-of-pv-adoption",
    "title": "Data",
    "section": "Share of PV adoption",
    "text": "Share of PV adoption\nWe estimate the period-wise share of PV adoption by income decile by calculating the proportion of households in each decile period with a PV installation. (fig_ProbabilityPV?) portrays the adoption share across deciles from the first period the SOEP started asking for PV installations (2007) and 2017. The likelihood of adoption grows with both income and time. While the average adoption rate across income deciles in 2007 was 1.3%, it rose slightly above 10% in 2017. Concerning inter-decile differences, on average, 2.27% and 13.32% of households in the lowest and highest income decile have a PV installation.\n\n\n\n\n\nShow the Code\n#### Load the data\nfile = gsub(\"WebsiteABM\", \"\", getwd())\nsum = read_rds(paste0(file, \"02_GenData/03_SoepFiles/PvProbability.rds\"))\n\n#### Plot the probability of adoption for houses and flats\nggplot(sum) + geom_line(aes(y = prob, x = year, group = IncomeGroup, color = IncomeGroup)) + \n  geom_point(aes(y = prob, x = year, color = IncomeGroup)) + theme_economist() %+replace%\n  theme(strip.text = element_text(hjust = 0), legend.title = element_blank()) +\n  labs(x = \"\", y = \"\") + scale_color_viridis(discrete = T) +\n  scale_x_continuous(breaks = pretty_breaks())\n\n\n\n\n\nFigure 10: Probability of PV adoption across income Deciles"
  },
  {
    "objectID": "02_data.html#estimating-wealth",
    "href": "02_data.html#estimating-wealth",
    "title": "Data",
    "section": "Estimating Wealth",
    "text": "Estimating Wealth\nWe estimate the gross wealth of each households with an ordinary least squares model of gross wealth as a function of income and the age of the household head. The estimation model takes the form:\n\\[\nWealth_{ht} = \\beta Income_{ht} + \\gamma Age_{ht} + \\epsilon_{ht}\n\\]\nTable 24 contains the point estimates and standard errors from the OLS. As expected there is a positive relationship between income, age, and gross wealth.\n\n\nShow the Code\n#### Read the fitted data \nfile = gsub(\"WebsiteABM\", \"\", getwd())\nest = read_rds(paste0(file, \"02_GenData/03_SoepFiles/WealthEst.rds\"))\n\n#### Transform to a data frame long\nest = gather(est |> select(-spec) , var, value) |> \n  mutate(stat = gsub(\".*_\", \"\", var)) %>% \n  mutate(var = gsub(\"_.*\", \"\", var)) %>% \n  spread(., var, value)\n\n\nkbl(est) %>% \n    kable_classic_2(full_width = F, html_font = \"Cambria\") %>% \n  kable_styling(bootstrap_option = c(\"hover\"))\n\n\n\n\nTable 24:  Estimates for the relationship between gross wealth income and age \n \n  \n    stat \n    age \n    income \n    Intercept \n  \n \n\n  \n    est \n    2757.12638 \n    4.9958563 \n    -176262.078 \n  \n  \n    se \n    64.51511 \n    0.0367784 \n    4082.583 \n  \n\n\n\n\n\n\nWe test the robustness of our econometric specification by varying the set of controls in the OLS design. Model (1) is our preferred specification with linear controls for income and age. (2) adds quadratic controls for both variables. (3) further includes education as an additional control. (4) includes year fixed effects to account for common temporal shocks across households. Finally, in five we estimate the coefficients from within variation in income by including households fixed effects.\n\n\nShow the Code\n#### Read the fitted data \nfile = gsub(\"WebsiteABM\", \"\", getwd())\nfitted = read_rds(paste0(file, \"02_GenData/03_SoepFiles/WealthFitted.rds\"))\n\n#### Plot the density funtion ####\nplot = gather(fitted, var, value, -c(hid, year, income, age, education, GrossWealth))\n\n#### Make the raw bar plot ####\nplot %>% group_by(var) %>% filter(value < quantile(value, p = 0.99, na.rm = T)) %>% ggplot(.) + \n  geom_histogram(aes(value/1000, fill = var), alpha = 0.5, \n                 position =position_dodge2(width = 1.5), binwidth = 100) +\n  theme(panel.background = element_blank(), legend.position = \"top\", \n        axis.line = element_line(), legend.background = element_blank(), \n        legend.title = element_blank()) +\n  grids() + scale_fill_viridis_d(option = \"D\") +\n  labs(y = \"No. of Households\", x = \"Wealth in Ths.\")\n\n\n\n\n\nFigure 11: Fitted wealth distribution across different OLS models"
  },
  {
    "objectID": "04_model.html",
    "href": "04_model.html",
    "title": "Model Overview",
    "section": "",
    "text": "Before providing a detailed outline of the model (see below), we briefly describe the basic intuition underlying the agent-based model we use to simulate the household decision to adopt a technology. At present, the model only depicts the adoption of photovoltaic (PV) systems, but a similar framework could also be applied to other technologies such as heat pumps, insulation, or AC systems.\nThe adoption decision in the model is based on a simple expected utility framework; in every period \\(t = 1,...,T\\) (where one period represents one year), each household \\(h = 1,...,N\\) who does not already own PV faces the binary decision whether or not to purchase the single type of PV system available in the model. The expected utility from owning PV is a function of the (discounted) profit \\(h\\) expects to derive from the ownership of PV over the lifetime of the panel, as well as a component based on social influence/emulation and one based on the environmental attitude of \\(h\\). The expected profit from owning PV (stemming from an expected reduction in outlays for electricity and earnings through electricity fed into the grid) is in turn a function of the future electricity price expected by \\(h\\) as well as the feed-in tariff and the future electricity consumption of \\(h\\).\nHouseholds receive income, consume and pay electricity cost, resulting in changes in their stocks of liquid assets; these liquid assets can be used to purchase a solar panel. Households with insufficient liquid assets may also request a loan to install PV from a stylised banking sector, but may be credit-rationed if the bank is unwilling to lend them as much as they require."
  },
  {
    "objectID": "04_model.html#electricity-price",
    "href": "04_model.html#electricity-price",
    "title": "Model Overview",
    "section": "Electricity price",
    "text": "Electricity price\nDepending on the year which a given simulation period \\(t\\) is supposed to represent (past or future), the current electricity price to be paid by households in period \\(t\\)1 is either taken from a time-series of household-level electricity prices for Germany obtained from Eurostat, or simulated using an AR(1) model previously estimated on this empirical time-series. To estimate this AR(1) model, the time-series was differenced and then used to estimate the intercept (\\(\\phi_1\\)) and autoregressive (\\(\\phi_2\\)) parameter, with the residuals used to calculate the standard deviation of random shocks (\\(\\sigma^p\\)).\nIf no empirical observation is available for the electricity price in \\(t\\) (because \\(t\\) represents some year in the future), the electricity price in the model in \\(t\\) is given by:\n\\[\n    p_t=p_{t-1}+\\phi_1+\\phi_2 \\Delta p_{t-1}+\\epsilon^p_t \\rightarrow \\epsilon^p_t\\sim\\mathcal{N}(0,\\sigma^p)\n\\]"
  },
  {
    "objectID": "04_model.html#income-and-electricity-costs",
    "href": "04_model.html#income-and-electricity-costs",
    "title": "Model Overview",
    "section": "Income and electricity costs",
    "text": "Income and electricity costs\nIn every simulation period, we simulate the income of household \\(h=1,...,N\\) using a draw from the normally distributed variable \\(Y^h_t\\) with mean \\(\\overline{Y^h_t}\\) and standard deviation \\(\\widehat{Y^h_t}\\).\n\\[\n    Y^h_t\\sim \\mathcal{N}\\left(\\overline{Y^h_t},\\widehat{Y^h_t}\\right)\n\\]\nThe mean, \\(\\overline{Y^h_t}\\), is initialised using the income of \\(h\\) according to the SOEP data and grows at rate \\(g^h\\) in every period thereafter, i.e. \\(\\overline{Y^h_t}=(1+g^h)\\overline{Y^h_{t-1}}\\). \\(\\widehat{Y^h_t}\\) is given by \\(\\overline{Y^h_t}\\cdot\\sigma^y_d\\) where \\(\\sigma^y_d\\) is the standard deviation of income within the income decile \\(d\\) of household \\(h\\) in the SOEP data (expressed as % of average income in that decile)\nThe electricity consumption of each household (in kWh) is instead a deterministic variable, denoted \\(\\overline{E^h_t}\\). As with income, \\(\\overline{E^h_t}\\) is initialised using the electricity consumption of \\(h\\) taken from SOEP data (deflated by the empirical electricity price for the start year from the Eurostat dataset) and grows at rate \\(g^h\\) in every period thereafter, i.e. \\(\\overline{E^h_t}=(1+g^h)\\overline{E^h_{t-1}}\\).\nThe cost of electricity to be paid by \\(h\\) would then be \\(CE^h_t=p_t \\overline{E^h_t}\\). If \\(h\\) owns a solar panel (\\(PV^h_t=1\\)), however, this electricity cost will be reduced by the cost saving/revenue generated by the panel. The overall cost saving/revenue derived from a solar panel depends on two factors:\n\n\nWhether the current electricity consumption of \\(h\\), \\(\\overline{E^h_t}\\), is larger or smaller than the amount of electricity \\(G\\) which a solar panel can produce per period.\nWhether the feed-in tariff, \\(FIT^h_t\\) that \\(h\\) receives by selling the electricity that their panel produces is larger or smaller than the current price of electricity, \\(p_t\\).\n\n\nSince we assume that there is only one model of solar panel which agents can purchase and since we abstract from any variations in electricity output across agents due e.g. to hours of sun, position of the panel, etc., \\(G\\) is fixed, exogenous, and identical for all agents who own PV. \\(FIT^h_t\\) varies across agents; in particular, as is the case in reality in Germany, \\(FIT^h_t\\) depends on the year in which the solar panel was installed. For instance, if \\(h\\) bought a solar panel in 2015, they will receive the 2015 feed-in tariff (taken from empirical data for Germany) for the next 20 years (regardless of what happens to the electricity price), as is the case in reality. For simplicity, we assume that the lifespan of a panel is also 20 years (which is a broadly realistic value based on information material available online). The second condition above is important particularly because in the 2000s, the feed-in tariff in Germany for small PV units (up to 10kWp) was in fact higher than the average electricity price. When simulating past years, actual feed-in tariffs in force in the respective years are used. When simulating future years, the feed-in tariff is kept constant at its most recent value in the baseline simulation.\nIf \\(FIT^h_t>p_t\\), it is rational for the household to sell all electricity generated by the panel to the grid and buy any electricity needed back at the lower price; its electricity cost hence becomes\n\\[\n    CE^h_t=p_t \\overline{E^h_t}-FIT^h_tG\n\\] Note that this quantity may also be negative.\nIf \\(FIT^h_t<p_t\\), the household would want to consume some or even all of the electricity generated by the panel. Since we are assuming that PV systems in the model are not equipped with batteries, however, agents can only consume a maximum of \\(\\eta G\\) of the electricity generated by the panel, where \\(\\eta\\) is calibrated to the average share of own consumption out of electricity generated by household PV systems without a battery (information on this value was taken from consumer advice websites). Consequently, the electricity costs for households who own PV and for whom \\(FIT^h_t<p_t\\) is given by\n\\[\n  CE^h_t=p_t \\overline{E^h_t}-G\\eta p_t-G(1-\\eta)FIT^h_t\n\\] for households for whom \\(\\overline{E^h_t}\\geq G\\) and by\n\\[\nCE^h_t=p_t \\overline{E^h_t}-min\\left(\\eta G,\\overline{E^h_t}\\right)p_t-FIT^h_t\\left(G-min\\left(\\eta G,\\overline{E^h_t}\\right)\\right)\n\\] for households for whom \\(\\overline{E^h_t}< G\\).\nHouseholds who own PV keep track of the cumulative profit they have derived from their panel. In order to do so, the variable \\(\\Pi^h\\) is updated in every period by adding the respective current saving on electricity cost/revenue from selling to the grid.\nIn addition to ``gross” income defined above, we also keep track of income net of electricity cost:\n\\[\n    Y^{p,h}_t=min\\left(0,Y^h_t-CE^h_t\\right)\n\\]\nWe then calculate income distribution statistics (percentiles and deciles, used below) for period \\(t\\) using this income net of electricity cost."
  },
  {
    "objectID": "04_model.html#consumption",
    "href": "04_model.html#consumption",
    "title": "Model Overview",
    "section": "Consumption",
    "text": "Consumption\nEach household devotes a part of its ``gross” income to consumption expenditures (excluding electricity consumption which is determined as described above). The average propensity to consume of \\(h\\), \\(c^h_t\\), is determined using survey data from the German Federal Statistical Office, which gives household consumption expenditure by income group, converted into percentiles using SOEP data. \\(c^h_t\\) is hence the average propensity to consume of the income percentile in which \\(h\\) finds itself in period \\(t\\). The desired consumption expenditure of \\(h\\) is then given by\n\\[\n    C^h_t=(1-\\mu)C^h_{t-1}+\\mu c^h_t Y^{p,h}_t\n\\]\nwhere \\(\\mu\\) is a parameter giving the speed at which consumption expenditure adjusts to changes in income. In the initial period, we set \\(C^h_t=c^h_t Y^{p,h}_t\\).\nEach household in the model holds a stock of liquid assets (money) which is augmented by income and can be used to consume, pay for electricity, service debt and purchase a solar panel. To update the liquidity of \\(h\\), we first calculate the difference between income on the one hand and desired consumption expenditure and electricity cost on the other:\n\\[\n    Save^h_t=Y^h_t-C^h_t-CE^h_t\n\\]\nRecall that if \\(PV^h_t=1\\), \\(CE^h_t\\) may be negative.\nIn the first instance, \\(Save^h_t\\) is added to existing liquidity. Note that we assume that households cannot hold negative liquidity; if saving is negative and larger than previously accumulated liquidity, liquidity is set to 0 (implicitly assuming that the household reduces desired consumption expenditure and/or expenditure on electricity in order to be able to afford the payments):\n\\[\n    M^h_t=max\\left(0,M^h_{t-1}+Save^h_t\\right)\n\\]\nIn the model, households may incur debt in order to purchase a solar panel. At the beginning of the simulation, the debt of all households (including those already owning PV) is initialised to 0. In any period \\(t>0\\), households which in the past used a loan in order to buy PV and have not yet fully paid it off must make a debt service payment consisting of interest and principal payments, denoted by \\(S^h\\). \\(S^h\\) is determined when a household takes out a loan in order to adopt PV. Its calculation is explained in the description of the adoption decision below.\nPayments for debt service are made out of the stock of liquidity updated above:\n\\[\n    M^h_t=max\\left(0,M^h_t-S^h_t\\right)\n\\]\nNote that here, too, we assume that payments cannot lead to negative liquidity! If a household is unable to (fully) make its debt service payment out of liquidity, it pays as much as it can, making first the interest payment and then the principal payment. Unpaid principal payments mean that the stock of debt does not decrease as much as it would if the payment were made in full. Any unpaid interest payments are added to the household’s outstanding debt. In both of these cases, \\(S^h\\), i.e. the per-period debt service to be paid in the future is re-calculated taking into account unpaid principal and/or interest payments and the remaining term of the loan. In addition, any interest paid is subtracted from the cumulative profit derived from owning PV, \\(\\Pi^h\\) as it represents a cost.\nIn a final step, we include a saving allocation choice. This is done to make sure that average household liquidity does not grow too fast. In particular we assume that\n\\[\n    M^h_t=M^h_{t-1}+\\theta^h_t(M^h_t-M^h_{t-1}) \\quad if\\ M^h_t>M^h_{t-1}\n\\]\ni.e. we assume that if the household has positive saving, it puts only part of this into liquid assets (bank deposits etc.). \\(\\theta^h_t\\) is set using Bundesbank data from which we calculate the share of liquid assets in median gross wealth by income group, such that \\(\\theta^h_t\\) is the corresponding share for the income percentile in which \\(h\\) finds itself in period \\(t\\).\nThe initial value for liquidity is also set using these `liquidity shares’, alongside gross wealth data from SOEP."
  },
  {
    "objectID": "04_model.html#updating-panel-age",
    "href": "04_model.html#updating-panel-age",
    "title": "Model Overview",
    "section": "Updating panel age",
    "text": "Updating panel age\nThe model assumes that all solar panels have the same maximum lifespan, and the age of each panel in the model is augmented by 1 in each period. The age of panels already existing at the beginning of the simulation is taken from SOEP data. If a panel owned by a household \\(h\\) reaches the maximum lifespan in \\(t\\), the panel is scrapped and the state variable \\(PV^h_t\\) is set to 0. In addition, the feed-in tariff received by \\(h\\), \\(FIT^h_t\\) is set to 0. The household can then (see below) decide whether they wish to buy a new panel."
  },
  {
    "objectID": "04_model.html#electricity-price-expectations",
    "href": "04_model.html#electricity-price-expectations",
    "title": "Model Overview",
    "section": "Electricity price expectations",
    "text": "Electricity price expectations\nIn order to form an expectation about whether purchasing a solar panel is a profitable undertaking, households must have an expectation of the future electricity price over the lifespan of the panel. In line with a large literature on alternatives to the rational expectations hypothesis, it is assumed that each household uses recursive least squares learning in order to estimate an econometric model of the electricity price using past observations, which is then projected forward to generate a time-series of expected future electricity prices.\nIn particular, we assume that agents know that changes in the electricity price follow an AR(1) model, but they do not know the parameters of this model. They attempt to learn them using the recursive least squares formula with constant gain:\n\\[\nR^h_t =R^h_{t-1}+\\gamma^h\\left(x_t x_t'-R^h_{t-1}\\right)\\\\\nn^h_t =n^h_{t-1}+\\gamma^h\\left(R^h_t\\right)^{-1}x_t(y_t-x_t' n^h_{t-1})\n\\]\nwhere \\(x_t\\) is the vector of independent variables (in our case, since we are estimating an AR(1) with intercept, this vector will contain the elements 1 and \\(\\Delta p_{t-1}\\)). \\(y_t\\) is the dependent variable in \\(t\\) (i.e. \\(\\Delta p_{t}\\)). \\(R^h_t\\) is \\(h\\)’s current estimate of the moment matrix of \\(x\\). \\(n^h_t\\) is \\(h\\)’s current estimate of the vector of parameters (intercept and AR parameter). \\(\\gamma^h\\) is the so-called gain parameter, which determines how sensitive \\(h\\)’s estimates are to new observations.\nEach household \\(h\\) hence has an internal AR(1) model with the parameters contained in \\(n^h_t\\). Using the current electricity price, they can use this model to project the price forward, generating a time-series of expected future electricity prices which is used below to form an expected revenue from owning a solar panel.\n\\(R^h_t\\) and \\(n^h_t\\) are initialised uniformly across households and at the beginning of the simulation, the expectations formation algorithm is trained using the second time-series of electricity prices generated as a training dataset as described above. Note that if \\(\\gamma^h\\) differs across households, households will hold heterogeneous expectations."
  },
  {
    "objectID": "04_model.html#adoption-decision",
    "href": "04_model.html#adoption-decision",
    "title": "Model Overview",
    "section": "Adoption Decision",
    "text": "Adoption Decision\nThe decision on whether or not to adopt PV is based on a simple utility maximization framework; every household which does not already own a solar panel makes this decision in every simulation period. By assumption, there exists only one type of solar panel in the model, such that the adoption decision is a binary one between adopting and not adopting. The solar panel has an installation cost \\(K_t\\) which is uniform for every household and which changes over time (if we are simulating past years, empirical data on the cost of solar PV are used; for future years, these data are projected forward). As mentioned above, every solar panel generates a fixed amount of electricity \\(G\\) per period.\nPrior to deciding whether or not to purchase a solar panel based on utility considerations, every household which does not already own PV must check whether they are financially capable of adopting. If the accumulated liquidity of household \\(h\\), \\(M^h_t\\) is greater than \\(K_t\\), \\(h\\) can buy a panel outright and proceeds to the utility maximisation problem. If \\(M^h_t<K_t\\), \\(h\\) must obtain a loan of size \\(L^h=K_t-M^h_t\\).\nBy assumption, the bank in the model sets a maximum amount which it is prepared to lend to any given household \\(h\\), which is determined by \\(LTV\\cdot K_t\\) where \\(LTV\\leq1\\) (at present we are in fact working with \\(LTV=1\\) so this constraint is not binding for any agent). If \\(L^h>LTV\\cdot K_t\\), the household cannot obtain a loan of sufficient size; they are credit-rationed and cannot adopt. The bank also checks whether the household is financially capable of meeting the payments on a loan of size \\(L^h\\). The interest rate which the bank would charge on a loan to \\(h\\) is given by\n\\[\n    r^h=r_t+\\iota \\frac{L^h}{LTV\\cdot K_t}\n\\]\ni.e. the interest rate charged by the bank increases with the loan to value ratio implied by the loan. \\(r_t\\) is an exogenous base interest rate (if we are simulating past years, the average ECB base rate for that year is used; for future years, we take the currently effective rate and keep it constant in the baseline). Given that loans in the model are assumed to be amortising, and assuming that all loans in the model have a duration equal to the lifetime of a panel, \\(A\\), the per-period payment on a loan of size \\(L^h\\) at rate \\(r^h\\) would be\n\\[\n    S^h=L^h\\frac{r^h(1+r^h)^A}{(1+r^h)^A-1}\n\\]\nIf \\(S^h\\) exceeds a fraction \\(DTI\\) of the current income of \\(h\\), i.e. if \\(\\frac{S^h}{Y^h_t}>DTI\\) the household is also credit-rationed and cannot adopt. Otherwise, they proceed to the utility maximisation problem.\nComing to the utility maximisation part of the adoption decision, we assume that\n\\[\n    U^{h,PV=0}_{t}=0 \\quad \\forall\\  h \\in H \\ \\& \\ \\forall\\  t \\in T\n\\]\ni.e. the utility from not adopting PV is always zero for all households. This means that a household will adopt as soon as the utility from doing so is greater than zero (provided that they are not credit-constrained as described above). The utility from adopting is given by\n\\[\n    U_{t}^{h, PV = 1} | (F^{h}=1) = E^h_t(\\Pi^h)+\\alpha^h \\lambda^h_t+\\beta Env^{h}\\\\\n    U_{t}^{h, PV = 1} | (F^{h}=0) =0\n\\]\nFirst of all, note that \\(U_{t}^{h,PV = 1}\\) is conditional on \\(F^{h}\\). \\(F^{h}\\) is a dummy denoting the feasibility of PV, i.e. whether, given the characteristics of the dwelling of household \\(h\\), a solar panel can in fact be installed (e.g. installation may not be technically feasible or there may be administrative rules preventing installation). If \\(F^{h}=0\\), PV cannot be installed and the utility, correspondingly, is zero. At present, \\(F^h\\) is set for each household at the beginning of the simulation and remains fixed thereafter. If a household already owns PV at the beginning, it is set to 1. Otherwise it is set to 1 with probability 1 if the household lives in a house and with probability \\(p^f<1\\) if the household lives in a flat.\nFocus now on the case of \\(F^h=1\\). Going from right to left, the term \\(\\beta Env^{h}\\) captures the environmental attitude of the household. \\(Env^h\\) is a fixed household characteristic which takes 4 discrete levels (higher value=more concerned about the environment/climate change, the lowest value being 0), calibrated on Gallup survey data from the US. \\(\\beta Env^{h}\\) is supposed to reflect the intrinsic utility which \\(h\\) derives from owning PV regardless of whether or not it is profitable to do so.\n\\(\\alpha^h \\lambda^h_{t}\\) captures the element of social influence/emulation, where\n\\[\n    \\lambda^h_{t}=\\omega^{PV=1}_{d=d^h, t-1}-\\omega^{PV=0}_{d=d^h, t-1}\n\\]\n\\(\\omega^{PV=1}_{d=d^h, t-1}\\) is the share of households in the same income decile as \\(h\\) who owned PV at the end of the previous period, with \\(\\omega^{PV=0}_{d=d^h, t-1}\\) being the corresponding share of households in the same decile who own PV. \\(\\lambda^h_{t}\\) hence takes a value between \\(-1\\) and \\(1\\).\nFinally, the term \\(E^h_{t}(\\Pi^h)\\) denotes \\(h\\)’s expectation at time \\(t\\) of the cumulative profit, \\(\\Pi^h\\) which \\(h\\) will be able to derive from owning PV over the lifetime of a panel. This expected profit is given by:\n\\[\n    E^h_{t}(\\Pi^h)=\\sum_{a = 1}^{A}(\\rho^h)^a E^h_{t}(Rev^h_{t+a})-K_t-I^h\n\\]\n\\(\\sum_{a = 1}^{A}E^h_{t}(Rev^h_{t+a})\\) is the sum of future revenue/electricity cost saving which the household expects a solar panel to generate over its lifetime of \\(A\\) periods. Recall from above that in any period \\(t\\), the revenue/cost saving which an existing solar panel generates depends on the electricity price, the feed-in tariff received by the owner, as well as the electricity consumption of the household. In the same way, the expected revenue/cost saving generated by a panel in some future period \\(t+a\\) depends on:\n\n\nThe feed-in tariff which the household would receive if it buys a panel in \\(t\\)\nThe electricity price which the household expects to prevail in \\(t+a\\)\nThe (expected) electricity consumption of \\(h\\) in \\(t+a\\)\n\n\nThe feed-in tariff the agent will receive if it adopts PV in \\(t\\) is known. The expected price in \\(t+a\\) is given by the expectation formation mechanism described above. Regarding electricity consumption, recall that \\(\\overline{E^h_t}\\) is assumed to grow at a fixed rate \\(g^h\\) in every period; we assume that the household knows this, meaning that it can easily calculate its electricity consumption in \\(t+a\\). With these elements in place, the expected future revenue/cost saving for the next \\(A\\) periods can be calculated in the same way as current revenue/cost saving, described above (i.e. also checking whether the feed-in tariff is larger or smaller than the expected electricity price etc.). Expected revenue/cost saving in future periods is discounted by the individual discount rate of \\(h\\), \\(\\rho^h\\). The distribution of discount rates across agents is calibrated based on the existing literature on discount rate elicitation.\n\\(K_t\\) is the installation cost of the panel, which is the same for every household.\n\\(I^h\\), finally, is the financing cost of the panel. If no loan is needed, the loan cost is obviously 0. If a loan is needed, the cost is equal to the discounted sum of interest payments which will have to be made over the entire term of the loan. As set out above, the interest rate on the loan is given by\n\\[\n    r^h=r_t+\\iota \\frac{L^h}{LTV\\cdot K_t}\n\\]\nfrom which we can calculate a per-period loan payment as\n\\[\n    S^h=L^h\\frac{r^h(1+r^h)^A}{(1+r^h)^A-1}\n\\]\nKnowing the principal and per-period payment, we can calculate an amortisation schedule telling us how much principal and interest the household will have to pay in each future period, which in turn allows us to derive the loan cost as the discounted sum of future interest payments (note that principal payments are not a cost as they do not affect net worth, therefore they should not enter into the calculation of profit!).\nSince loans are not costless, it is possible that even if the discounted expected revenue from owning a panel exceeds the installation cost, overall expected profit may turn negative due to the implied financing cost.\nIn order to somewhat constrain the model dynamics (in particular to avoid the phenomenon of many agents who already owned a solar panel previously not buying a new one once the old one is scrapped, which can occur for some parameter settings), we make one further assumption:\nIf a household already owned PV in the past but is now no longer an owner because the panel reached its maximum age, then if that panel generated a positive cumulative profit over its lifespan (i.e. \\(\\Pi^h>0\\)), we set both \\(Env^{h}\\) and \\(\\alpha^h\\) to 0 for that household. This means that in considering whether to re-adopt PV, such a household will only consider the expected future profit. All other households sum up all three elements of utility (expected profit, social influence/emulation and environmental attitude).\nAll households for whom utility is positive, who do not already own a panel and who are not credit-rationed will adopt PV. Any loans taken out to do so are added to their balance sheets, their liquidity is updated, interest rates and loan payments are set (if applicable) and the PV dummies is set to 1. \\(FIT^h_t\\) is set to the feed-in tariff currently in force for all households adopting in \\(t\\) and remains unchanged over the lifetime of the panel.\nSince we are also keeping track of the actual cumulative profit \\(\\Pi^h\\) (not discounted) which a household derives from owning PV, the cumulative profit of all agents adopting PV in \\(t\\) is initialised to \\(\\Pi^h=-K_t\\)."
  },
  {
    "objectID": "04_model.html#policy",
    "href": "04_model.html#policy",
    "title": "Model Overview",
    "section": "Policy",
    "text": "Policy\nAt present, the model allows for 4 types of policy experiments:\n\n\nA subsidy on the purchase price of a panel, reducing \\(K_t\\) by some percentage\nAn addition to the feed-in tariff on top of the historical values fed exogenously into the model\nA relaxation of the maximum loan to value constraint (currently not relevant since we already set \\(LTV=1\\))\nA relaxation of the maximum debt-service to income constraint\n\n\nIn addition, different scenarios/experiments can be simulated by altering the time-series which are fed into the model exogenously (e.g. electricity price time-series, base interest rate, price of PV etc.). Finally, it is easily feasible to switch from the current expectation formation mechanism for the electricity price to a perfect foresight setting as the electricity price is completely independent from endogenous model dynamics."
  },
  {
    "objectID": "05_code.html",
    "href": "05_code.html",
    "title": "Model Code",
    "section": "",
    "text": "The model is written in Python. Below we provide a step-by-step documentation of all model functions. In total the model consists of 10 separate functions, which are in turn called by one main model function containing the initialisation and the main simulation loop. This main function is described last."
  },
  {
    "objectID": "05_code.html#generate-electricity-price",
    "href": "05_code.html#generate-electricity-price",
    "title": "Model Code",
    "section": "Generate Electricity Price",
    "text": "Generate Electricity Price\nThis function is called once at the beginning of a simulation run in order to generate a time-series of the electricity price which agents have to pay at each time-step of the simulation (note that this is different from the expected future electricity price, described below).\nThe function takes four inputs. _PriceEmp is a pandas dataframe containing an empirical time-series of the electricity price. _Params, is a pandas dataframe containing the names and values of the model parameters. _length, is an integer denoting the length of the time-series to be created (given by simulation length+2 since we need two lagged values at the beginning for the expectations formation process discussed below). Finally, _start denotes the start year of the simulation\nThe function then creates two numpy vectors of zeros of size _length. electricityprice1 is the vector of prices that will actually be used in the simulation. electricityprice2 instead is a vector of prices which will be used to train the agents’ expectations formation mechanism prior to the beginning of the simulation.\nThe first two elements of the vectors are set to the empirical values of the electricity price in _start-2 and _start-1. The rest of the vector electricityprice1 is then filled either with empirical values of the price (if these are available, e.g. because we are simulating past years rather than the future) or by iterating forward an AR(1) model previously estimated on the empirical price data, including a normally distributed random shock the standard deviation of which is taken from the standard deviation of the residuals from the estimation of the AR(1) model. electricityprice2, the “training set”, is filled completely with simulated values from the AR(1) model. Finally, the function returns the two time-series of the electricity price.\n\ndef GenerateElectricityPrice(_PriceEmp,_Params,_length,_start):\n    #Create vectors of zeros\n    electricityprice1=np.zeros(_length)\n    electricityprice2=np.zeros(_length)\n    #Set first two elements to empirical electricity price in _start-2 and _start-1\n    electricityprice1[0]=_PriceEmp[str(_start-2)].values[0]\n    electricityprice2[0]=_PriceEmp[str(_start-2)].values[0]\n    electricityprice1[1]=_PriceEmp[str(_start-1)].values[0]\n    electricityprice2[1]=_PriceEmp[str(_start-1)].values[0]\n    #Iterate over rest of vector\n    for t in range(2,_length):\n        #If the empirical price-series still contains values, use them to fill electricityprice1\n        if sum(str(_start-2+t)==_PriceEmp.columns)==1:\n            electricityprice1[t]=_PriceEmp[str(_start-2+t)].values[0]\n        else:\n        #Otherwise, fill the rest of electricityprice1 with simulated prices using a previously estimated AR1 model\n            #Generate normally distributed shock based on standard deviation of regression residuals\n            shock1=_Params[\"ElectricityPriceSD\"].values[0]*np.sqrt(-2*np.log(np.random.uniform(0,1,1)))*np.cos(2*np.pi*np.random.uniform(0,1,1))\n            #Price in t calculated by iterating AR(1) model\n            electricityprice1[t]=electricityprice1[t-1]+_Params[\"ElectricityPriceTrend\"].values[0]+_Params[\"ElectricityPriceAR\"].values[0]*(electricityprice1[t-1]-electricityprice1[t-2])+shock1 \n        #electricityprice2, which is used to train the expectations formation mechanism, is filled completely with simulated values\n        #Generate normally distributed shock based on standard deviation of regression residuals\n        shock2=_Params[\"ElectricityPriceSD\"].values[0]*np.sqrt(-2*np.log(np.random.uniform(0,1,1)))*np.cos(2*np.pi*np.random.uniform(0,1,1))\n        #Price in t calculated by iterating AR(1) model\n        electricityprice2[t]=electricityprice2[t-1]+_Params[\"ElectricityPriceTrend\"].values[0]+_Params[\"ElectricityPriceAR\"].values[0]*(electricityprice2[t-1]-electricityprice2[t-2])+shock2\n    return [electricityprice1,electricityprice2]"
  },
  {
    "objectID": "05_code.html#set-policy",
    "href": "05_code.html#set-policy",
    "title": "Model Code",
    "section": "Set Policy",
    "text": "Set Policy\nDepending on the values of various dummies in the _Params dataframe and the current simulation period _year, this function determines whether a policy experiment should be activated in the current period.\nAt present, the model includes four possible policies, namely a subsidy on the cost of a solar panel (Subsidy1), a subsidy on the price at which electricity generated by PV can be sold to the grid (Subsidy2), a policy increasing the maximum permitted loan to value ratio for bank loans to acquire PV (CreditPolicy1, currently not used since in the baseline the maximum LTV is already set to 1), and a policy increasing the maximum allowed debt service to income ratio resulting from a loan made to acquire PV (CreditPolicy2). For instance, if the dummy _Subsidy1 is set to 1 and if the current simulation period (expressed as a year) is equal to or larger than SubsidyStart, a subsidy on the installation cost of PV will be activated. The function checks the conditions for the respective policy variables in each period, changes them if necessary, and then returns them.\n\ndef SetPolicy(_Subsidy1,_Subsidy2,_CreditPolicy1,_CreditPolicy2,_year,_Params):\n    if _Params[\"Subsidy1\"].values[0]==1 & _year>=_Params[\"SubsidyStart\"].values[0]:\n        _Subsidy1=_Params[\"s1\"].values[0]\n    if _Params[\"Subsidy2\"].values[0]==1 & _year>=_Params[\"SubsidyStart\"].values[0]:\n        _Subsidy2=_Params[\"s2\"].values[0]\n    if _Params[\"CreditPolicy1\"].values[0]==1 & _year>=_Params[\"CreditPolicyStart\"].values[0]:\n        _CreditPolicy1=_Params[\"cp1\"].values[0]\n    if _Params[\"CreditPolicy2\"].values[0]==1 & _year>=_Params[\"CreditPolicyStart\"].values[0]:\n        _CreditPolicy2=_Params[\"cp2\"].values[0]\n    return[_Subsidy1,_Subsidy2,_CreditPolicy1,_CreditPolicy2]"
  },
  {
    "objectID": "05_code.html#income-and-power-cost",
    "href": "05_code.html#income-and-power-cost",
    "title": "Model Code",
    "section": "Income and Power cost",
    "text": "Income and Power cost\nThis function generates the incomes and electricity costs for each agent in every period. _Income_f and _Powercost_f are vectors of length N, where N is the number of agents in the model. The deterministic values of income and power cost for each agent are assumed to grow at rate _Trend (which may be heterogeneous across agents but is currently uniform) at each time step. The electricity cost to be paid by each agent is deterministic, while their income in the current period is drawn from a normal distribution with mean _Income_f and standard deviation _Income_sd.\nHaving determined income and power cost for each agent, we move on to calculate the revenue/cost saving generated by solar panels in the current period. We begin by setting panelrevenue as a copy of _PV, a vector of dummies indicating whether an agent owns PV in the current period. Hence panelrevenue is zero (and will remain zero in the calculations below) for agents who do not own PV.\nWe then calculate panelrevenue for the agents who do own PV, by dividing them into 4 groups depending on whether their own electricity consumption in the current period is larger or smaller than the capacity of the solar panel and whether their feed-in tariff (FIT; possibly including an additional subsidy if one is in force, see the function above) is higher or lower than the current electricity price (note that, as in reality in Germany, the feed-in tariff depends on the year in which the PV was installed and remains constant thereafter, meaning that agents will receive different FITs depending on how old their panel is). panelrevenue is then set for each of the four groups, assuming that agents can consume a maximum of _Params[\"PVCons\"].values[0] of the amount of electricity generated by the panel.\nThe electricity cost of agents owning PV is then reduced by panelrevenue (note that this can lead to cases in which electricity cost becomes smaller than 0 when the revenue from the panel exceeds electricity cost). In addition, _CumulativeProfit, which keeps track of the profit which PV owners have derived from their panel over its lifetime, is updated. Finally, we calculate a measure of income net of electricity cost which is used below to calculate income distribution statistics.\n\ndef IncomePowercost(_Income_f,_Trend,_Powercost_f,_Income_sd,_CumulativeProfit,_PV,_Price,_PanelFIT,_Subsidy2,_Params):\n    #Deterministic income and power cost values grow at exogenous trend\n    _Income_f=_Income_f*(1+_Trend)\n    _Powercost_f=_Powercost_f*(1+_Trend)\n    #Actual income is drawn from a normal distribution with mean _Income_f and standard deviation _Income_sd\n    randincome=np.random.uniform(0,1,_Income_f.size)\n    randincome2=np.random.uniform(0,1,_Income_f.size)\n    randincome=np.sqrt(-2*np.log(randincome))*np.cos(2*np.pi*randincome2)\n    randincome=_Income_sd*randincome*_Income_f+_Income_f\n    randincome=np.maximum(1e-10,randincome)\n    #Power cost is multiplied by current electricity price\n    powercost=_Powercost_f*_Price\n    #Calculate revenue/cost saving generated by existing solar panels in the current period. Note that if _PV=0, panelrevenue=0\n    panelrevenue=_PV.copy()\n    #Agents who own PV, whose electricity consumption exceeds the capacity of the panel and whose FIT is smaller than the current electricity price\n    group1=np.where((_PV==1) & (_Powercost_f>=_Params[\"PVCapacity\"].values[0]) & ((_PanelFIT+_Subsidy2)<_Price))\n    #Agents who own PV, whose electricity consumption exceeds the capacity of the panel and whose FIT is larger than the current electricity price\n    group2=np.where((_PV==1) & (_Powercost_f>=_Params[\"PVCapacity\"].values[0]) & ((_PanelFIT+_Subsidy2)>=_Price))\n    #Agents who own PV, whose electricity consumption is smaller than the capacity of the panel and whose FIT is smaller than the current electricity price\n    group3=np.where((_PV==1) & (_Powercost_f<_Params[\"PVCapacity\"].values[0]) & ((_PanelFIT+_Subsidy2)<_Price))\n    #Agents who own PV, whose electricity consumption is smaller than the capacity of the panel and whose FIT is larger than the current electricity price\n    group4=np.where((_PV==1) & (_Powercost_f<_Params[\"PVCapacity\"].values[0]) & ((_PanelFIT+_Subsidy2)>=_Price))\n    #Revenue of group 1 is given by share of own consumption times capacity times price plus electricity fed into the grid times FIT\n    panelrevenue[group1]=_Params[\"PVCons\"].values[0]*_Params[\"PVCapacity\"].values[0]*_Price+(1-_Params[\"PVCons\"].values[0])*_Params[\"PVCapacity\"].values[0]*(_PanelFIT[group1]+_Subsidy2)\n    #Revenue of group 2 is given by capacity times FIT\n    panelrevenue[group2]=_Params[\"PVCapacity\"].values[0]*(_PanelFIT[group2]+_Subsidy2)\n    #Revenue of group 3 is given by minimum between own consumption share times capacity times price and electricity consumption times price, plus the remaining capacity of the panel times FIT\n    panelrevenue[group3]=np.minimum(_Params[\"PVCons\"].values[0]*_Params[\"PVCapacity\"].values[0],_Powercost_f[group3])*_Price+(_PanelFIT[group3]+_Subsidy2)*(_Params[\"PVCapacity\"].values[0]-np.minimum(_Params[\"PVCons\"].values[0]*_Params[\"PVCapacity\"].values[0],_Powercost_f[group3]))\n    #Revenue of group 4 is given by capacity times FIT\n    panelrevenue[group4]=_Params[\"PVCapacity\"].values[0]*(_PanelFIT[group4]+_Subsidy2)\n    #Reduce electricity cost by the revenue/cost saving generated by solar panels\n    powercost=powercost-panelrevenue\n    #Update cumulative profit of PV owners\n    _CumulativeProfit[_PV==1]=_CumulativeProfit[_PV==1]+panelrevenue[_PV==1]\n    #Calculate income net of power cost\n    income_p=randincome-powercost\n    income_p=np.maximum(0,income_p)\n    return[randincome,powercost,income_p,_CumulativeProfit,_Income_f,_Powercost_f]"
  },
  {
    "objectID": "05_code.html#income-groups",
    "href": "05_code.html#income-groups",
    "title": "Model Code",
    "section": "Income Groups",
    "text": "Income Groups\nThe purpose of this function is to calculate income distribution statistics, as well as the rates of PV ownership by income decile, which are used in other parts of the model. We begin by sorting _Income_p, the vector containing income net of electricity cost, in ascending order. Next, we set the cut-off points for income deciles and percentiles using the vectors _Positions_p and _Positions_d, which are calculated during the initialisation phase (described below) based on the number of agents in the model and give the number of agents in each decile/percentile. Next we iterate over all deciles and percentiles, assinging to each agent their income decile/percentile based on their current income net of electricity cost.\nThe function returns _IncomePercentiles and _IncomeDeciles, two vectors of length N, in which each element gives the income percentile/decile of the respective agent.\n\ndef IncomeGroups(_Income_p,_Positions_p,_Percentiles,_Positions_d,_Deciles,_IncomePercentiles,_IncomeDeciles):\n    #Sort income net of electricity cost in ascending order\n    income_psorted=np.sort(_Income_p)\n    #Based on sorted income and number of agents in each decile/percentile, set cut-off points\n    _Percentiles[0:99]=income_psorted[_Positions_p]\n    _Percentiles[99]=income_psorted[((income_psorted.size)-1)]\n    _Deciles[0:9]=income_psorted[_Positions_d]\n    _Deciles[9]=income_psorted[((income_psorted.size)-1)]\n    #Iterate over deciles\n    for i in range(10):\n        #Determine which agents belong to decile i\n        if i==0:\n            members=np.where(_Income_p<=_Deciles[i])\n        else:\n            members=np.where((_Income_p<=_Deciles[i]) & (_Income_p>_Deciles[(i-1)]))\n        #Set decile of all members to i\n        _IncomeDeciles[members]=i\n    #Iterate over percentiles\n    for i in range(100):\n        #Determine which agents belong to percentile i\n        if i==0:\n            members=np.where(_Income_p<=_Percentiles[i])\n        else:\n            members=np.where((_Income_p<=_Percentiles[i]) & (_Income_p>_Percentiles[(i-1)]))\n        #Set percentile of all members to i\n        _IncomePercentiles[members]=i\n    return[_IncomePercentiles,_IncomeDeciles]"
  },
  {
    "objectID": "05_code.html#consumption-and-saving",
    "href": "05_code.html#consumption-and-saving",
    "title": "Model Code",
    "section": "Consumption and saving",
    "text": "Consumption and saving\nThis function determines agents’ consumption and saving. In addition, agents with positive outstanding debt make debt service payments. The main purpose of this is to update agents’ _Liquidity , i.e. their stock of liquid assets (money) which can be used to buy PV.\nThe function begins by setting a consumption propensity out of income net of electricity cost for each agent based on their current income percentile. From this, their desired consumption is determined, including a persistence component. Income, electricity cost and desired consumption are then used to calculate the desired saving of each agent. If an agent cannot finance their desired consumption and electricity cost using current income and accumulated liquid assets, their actual consumption is implicitly curtailed such that their liquidity does not become negative (since we assume that households cannot borrow for consumption but only to acquire PV).\nNext, agents with positive debt make debt service payments, which are divided into principal payments (which reduce the stock of outstanding debt) and interest payments. Any interest payments which agents cannot afford are added to their balance of outstanding debt and their debt service payments for the following periods are updated accordingly. Agents whose debt has become zero in the current period (i.e. they have paid off their full loan) have their interest rate and debt service payments set to zero. _CumulativeProfit, which keeps track of the profit/cost saving which PV owners have derived from their solar panel is updated using interest payments made.\nFinally, if an agent has positive saving after debt service in the current period, their liquidity is updated by a fraction of that increment. This fraction is based on the agent’s current income decile and reflects the share of financial wealth held as liquid assets by income group.\nThe function returns agents’ updated current liquidity, debt, debt service payments, loan interest rates and desired consumption (the latter is used in the next period to calculate the persistence component of desired consumption).\n\ndef ConsumptionSaving(_Income_p,_Propensities,_IncomePercentiles,_Consumption,_Income,_Powercost,_Liquidity,_Debt,_DebtService,_LoanRate,_PanelAge,_CumulativeProfit,_LiquidityShares,_Params,_period):\n    #Determine agents' consumption propensities out of income net of electricity cost based on their current income percentile\n    consshares=_Propensities[_IncomePercentiles.astype(int)]\n    #Determine desired consumption\n    if _period==0:\n        _Consumption[:]=consshares*_Income_p\n    else:\n        #If simulation period>0, take into account persistence in desired consumption\n        _Consumption[:]=_Params[\"PersistenceConsumption\"].values[0]*_Consumption[:]+(1-_Params[\"PersistenceConsumption\"].values[0])*consshares*_Income_p\n    #Agents' desired saving is gross income minus (desired) consumption minus electricity cost\n    saving=_Income-_Consumption-_Powercost\n    #Save pre-consumption liquidity (stock of money) of each agent\n    Liquidity_p=_Liquidity.copy()\n    #If liquidity and income are greater than consumption plus electricity cost, update liquidity using saving (which may be negative!)\n    _Liquidity[(Liquidity_p+_Income)>=(_Consumption+_Powercost)]=_Liquidity[(Liquidity_p+_Income)>=(_Consumption+_Powercost)]+saving[(Liquidity_p+_Income)>=(_Consumption+_Powercost)]\n    #Otherwise, liquidity is set to 0; consumption is implicitly reduced to ensure liquidity does not become negative\n    _Liquidity[(Liquidity_p+_Income)<(_Consumption+_Powercost)]=0\n    #Determine debt service for agents with positive debt\n    _DebtService[_Debt>0]=np.minimum(_DebtService[_Debt>0],_Debt[_Debt>0])\n    #Decompose debt service into interest and principal component\n    interest=_LoanRate*_Debt\n    principal=_DebtService-interest\n    #Update remaining term of loan\n    term=np.maximum(1,_Params[\"PVMaxAge\"].values[0]-_PanelAge)\n    #Principal is paid if agent can afford to do so; debt is reduced\n    _Debt[_Liquidity>=_DebtService]=_Debt[_Liquidity>=_DebtService]-principal[_Liquidity>=_DebtService]\n    #Agents who cannot afford full principal pay as much as they can\n    _Debt[(_Liquidity>=interest) & (_Liquidity<_DebtService)]=_Debt[(_Liquidity>=interest) & (_Liquidity<_DebtService)]-_Liquidity[(_Liquidity>=interest) & (_Liquidity<_DebtService)]\n    #Any unpaid interest is added to outstanding debt\n    _Debt[_Liquidity<interest]=_Debt[_Liquidity<interest]+interest[_Liquidity<interest]-_Liquidity[_Liquidity<interest]\n    #Update cumulative profit of PV owners by interested paid on loans to acquire PV\n    interest[_Liquidity<interest]=interest[_Liquidity<interest]-_Liquidity[_Liquidity<interest]\n    _CumulativeProfit=_CumulativeProfit-interest\n    #Find agents who did not fully service debt\n    adjustservice=np.where(_Liquidity<_DebtService)\n     #Update liquidity based on debt service made\n    Liquidity_pd=_Liquidity.copy()\n    _Liquidity[Liquidity_pd<_DebtService]=0\n    _Liquidity[Liquidity_pd>=_DebtService]=_Liquidity[Liquidity_pd>=_DebtService]-_DebtService[Liquidity_pd>=_DebtService]\n    #Adjust debt service of agents who did not pay full debt service\n    _DebtService[adjustservice]=_Debt[adjustservice]*(_LoanRate[adjustservice]*np.power((1+_LoanRate[adjustservice]),term[adjustservice]))/(np.power((1+_LoanRate[adjustservice]),term[adjustservice])-1)\n     #Set loan rate, debt service and debt of agents who have paid off their loans to 0 (<=0) is used here since rounding errors can lead to slightly negative debt\n    _LoanRate[_Debt<=0]=0\n    _DebtService[_Debt<=0]=0\n    _Debt[_Debt<=0]=0\n    #Update liquidity based on shares of savings going into liquid assets by income percentile\n    shares=_LiquidityShares[_IncomePercentiles.astype(int)]\n    _Liquidity[_Liquidity>Liquidity_p]=Liquidity_p[_Liquidity>Liquidity_p]+shares[_Liquidity>Liquidity_p]*(_Liquidity[_Liquidity>Liquidity_p]-Liquidity_p[_Liquidity>Liquidity_p])"
  },
  {
    "objectID": "05_code.html#augment-panel-age",
    "href": "05_code.html#augment-panel-age",
    "title": "Model Code",
    "section": "Augment panel age",
    "text": "Augment panel age\nThis short function augments the age of all solar panels in the model by one period. If the panel of an agent has reached its maximum age, the value of _PV is set to zero for that agent, as is the value of _PanelAge and _PanelFIT which gives the FIT received. The agent is then no longer a PV owner and will face the adoption decision again.\n\ndef AugmentPanelAge(_PV,_PanelAge,_PanelFIT,_Params):\n    _PanelAge[_PV==1]=_PanelAge[_PV==1]+1\n    _PV[_PanelAge>_Params[\"PVMaxAge\"].values[0]]=0\n    _PanelFIT[_PanelAge>_Params[\"PVMaxAge\"].values[0]]=0\n    _PanelAge[_PanelAge>_Params[\"PVMaxAge\"].values[0]]=0\n    return[_PanelAge,_PV,_PanelFIT]"
  },
  {
    "objectID": "05_code.html#expectations-formation",
    "href": "05_code.html#expectations-formation",
    "title": "Model Code",
    "section": "Expectations formation",
    "text": "Expectations formation\nThis function is used to generate a time-series of expected future electricity prices for each agents. These are needed below when agents decide whether or not to adopt PV.\nExpectations formation of our bounded rational agents takes place using the well-established recursive least squares algorithm. Each agent has their own “internal” AR(1) model of the electricity price, the coefficients of which they update in every period using the latest observation of the actual electricity price in the model. Depending on the parameter setting, each individual agents may use a specific gain parameter to update their estimations, in which case the expected electricity prices differ across agents. In particular, agents with a high gain parameter will tend to update their estimated coefficients more strongly in reaction to new information, while agents with a low gain parameter will react less.\nThe first part of the function updates the internal AR(1) models of the agents, while the second projects the models to generate time-series of a length equal to the maximum lifespan of a solar panel. The function then returns the coefficients variance-covariance matrices of the updated AR(1) models and the time-series of expected prices.\n\ndef FormExpectation(_ARPars,_ARMats,_Price,_Gain,_ExpectedPrice,_period):\n    #Generate vector of independent variables --> constant=1 and current change in price\n    independent=np.array([[1],[(_Price[(_period+1)]-_Price[_period])]])\n    #Update variance-covariance matrices following recursive least squares algorithm\n    mat1=np.dot(independent,independent.transpose())\n    ARMatsNew=_ARMats+_Gain[:,None,None]*(mat1-_ARMats)\n    #Test for singularity of updated matrices\n    test=np.linalg.det(ARMatsNew)\n    if(sum(test==0)>0):\n        print('One or more matrices are singular!')\n    #If updated matrix of an agent is singular, use old matrix\n    _ARMats[np.where(test!=0)]=ARMatsNew[np.where(test!=0)]\n    #Update coefficient estimates of agents' AR(1) models\n    transposes=_ARPars.swapaxes(1,2)\n    result1=np.dot(transposes,independent)\n    dependent=_Price[(_period+2)]-_Price[(_period+1)]\n    result1=dependent-result1\n    result1=independent*result1\n    result1=np.linalg.solve(_ARMats,result1)\n    _ARPars=_ARPars+_Gain[:,None,None]*result1\n    transposes1=_ARPars[:,0].transpose()\n    transposes2=_ARPars[:,1].transpose()\n    #Generate time-series of expected electricity price for each agent\n    _ExpectedPrice[:,0]=(_Price[(_period+2)]+_ARPars[:,0]+_ARPars[:,1]*(_Price[(_period+2)]-_Price[(_period+1)])).transpose()\n    _ExpectedPrice[:,1]=_ExpectedPrice[:,0]+transposes1+transposes2*(_ExpectedPrice[:,0]-_Price[(_period+2)])\n    for t in range(2,len(_ExpectedPrice[0])):\n        _ExpectedPrice[:,t]=_ExpectedPrice[:,(t-1)]+transposes1+transposes2*(_ExpectedPrice[:,(t-1)]-_ExpectedPrice[:,(t-2)])\n    return[_ARMats,_ARPars,_ExpectedPrice]"
  },
  {
    "objectID": "05_code.html#adoption-decision",
    "href": "05_code.html#adoption-decision",
    "title": "Model Code",
    "section": "Adoption Decision",
    "text": "Adoption Decision\nIn this function, agents who do not yet own PV decide whether or not to purchase a panel.\nThe function first checks which agents would need a loan in order to adopt PV (namely those who do not have sufficient liquid assets to buy one outright). Based on the size of the loan needed, agents may be credit rationed if the resulting loan to value ratio exceeds the maximum permitted level (note that in the current implementation, _Params[\"MaxLTV\"]=1 such that this rationing mechanism is effectively switched off).\nNext, the bank proposes a loan interest rate to every agent with positive borrowing needs based on the size of the required loan. From this, in turn, we calculate the size of the implied debt service payment. If the prospective debt service payment of an agent exceeds a certain fraction (_Params[\"MaxDTI\"]) of their current income, the agent is credit rationed. Since the model only includes a single type of solar panel with a given installation cost, credit rationed agents cannot adopt (i.e. they cannot, for instance, buy a smaller panel with a smaller loan).\nThe function then calculates, for each agent, a sum of expected discounted revenue from owning PV over the lifetime of a panel, based on agents’ expected future electricity prices, the value of the feed-in tariff for panels installed in the current year, agents’ future electricity consumption (which, as outlined above, grows at a fixed rate every year), as well as a sum of discounted future loan costs based on the size of the needed loan and the interest rate proposed by the bank. As in the case of the function IncomePowercost outlined above, in calculating the expected cost-saving/revenue from owning PV, agents are divided into groups depending on whether their future electricity consumption is larger or smaller than the capacity of the solar panel and whether the current FIT is larger or smaller than the expected electricity price. Based on the cumulative discounted expected revenue and loan cost and the one-off installation cost, an expected profit from owning PV is calculated.\nThis expected profit, in turn, feeds into the expected utility from adopting PV. In addition to profit, this utility also contains a component related to social influence (based on the difference between the share of other agents in a given agent’s income decile who have already adopted PV and those who have not) and one related to environmental attitude.\nAgents for whom expected utility is positive (and for whom PV is technically feasible and who are not credit-rationed) purchase a solar panel and their liquidity, debt, debt service payments and loan rates are updated accordingly.\n\ndef AdoptionDecision(_PV,_Feasible,_Liquidity,_Rationed,_Debt,_Income,_Income_f,_Powercost_f,_Trend,_ExpectedPrice,_Discount,_Revenue,_LoanCost,_PVOwnershipDeciles,_IncomeDeciles,_LoanRate,_DebtService,_Influence,_Attitude,_Adopted,_CumulativeProfit,_FIT,_year,_PanelFIT,_Baserate,_Subsidy1,_Subsidy2,_CreditPolicy1,_CreditPolicy2,_Params):\n    #Reset vector of dummies indicating whether agents are credit-rationed\n    _Rationed[:]=0\n    #Calculate loan needed to purchase PV\n    loanneeded=(1-_Subsidy1)*_Params[\"PanelCost\"].values[0]-_Liquidity\n    #Agents who already have PV do not need a loan\n    loanneeded[_PV==1]=0\n    #Agents who can buy the panel outright do not need a loan\n    loanneeded[(_PV==0) & (_Liquidity>=((1-_Subsidy1)*_Params[\"PanelCost\"].values[0]))]=0\n    #Agents for whom PV is not technically feasible do not need a loan\n    loanneeded[_Feasible==0]=0\n    #Check whether needed loan exceeds maximum loan to value ratio\n    _Rationed[(loanneeded+_Debt)>((1-_Subsidy1)*_Params[\"PanelCost\"].values[0]*(_Params[\"MaxLTV\"].values[0]+_CreditPolicy1))]=1\n    #Calculate interest rate proposed by the bank based on size of loan needed\n    proposedrate=_Baserate[str(_year)].values[0]+_Params[\"InterestMarkup\"].values[0]*(1+loanneeded/((1-_Subsidy1)*_Params[\"PanelCost\"].values[0]*_Params[\"MaxLTV\"].values[0]))\n    #Calculate size of debt service payments\n    payment=loanneeded*(proposedrate*(np.power(1+proposedrate,_Params[\"PVMaxAge\"].values[0])))/((np.power(1+proposedrate,_Params[\"PVMaxAge\"].values[0]))-1)\n    #Check whether implied debt service to income ratio exceeds maximum permitted\n    _Rationed[(payment/_Income)>(_Params[\"MaxDTI\"].values[0]+_CreditPolicy2)]=1\n    #Agents who do not need a loan are not rationed\n    _Rationed[loanneeded==0]=0\n    #Agents for whom PV is not technically feasible are not rationed\n    _Rationed[_Feasible==0]=0\n    #Agents who already own PV are not rationed\n    _Rationed[_PV==1]=0\n    #Initialise expected revenue from PV and cost of loan\n    _Revenue[:]=0\n    _LoanCost[:]=0\n    #Initialise cost saving from PV\n    costsaving=_Revenue.copy()\n    #Initial remaining loan balance is equal to size of loan needed\n    balanceremaining=loanneeded.copy()\n    #Iterate over lifespan of a solar panel\n    for t in range(_Params[\"PVMaxAge\"].values[0]):\n        costsaving[:]=0\n        #Agents whose expected electricity consumption exceeds the capacity of the panel and for whom the current FIT is smaller than the expected electricity price\n        group1=np.where((_ExpectedPrice[:,t]>=(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))>=_Params[\"PVCapacity\"].values[0]))\n        #Agents whose expected electricity consumption is smaller than the capacity of the panel and for whom the current FIT is smaller than the expected electricity price\n        group2=np.where((_ExpectedPrice[:,t]>=(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))<_Params[\"PVCapacity\"].values[0]))\n        #Agents whose expected electricity consumption exceeds the capacity of the panel and for whom the current FIT is larger than the expected electricity price\n        group3=np.where((_ExpectedPrice[:,t]<(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))>=_Params[\"PVCapacity\"].values[0]))\n        #Agents whose expected electricity consumption is smaller than the capacity of the panel and for whom the current FIT is larger than the expected electricity price\n        group4=np.where((_ExpectedPrice[:,t]<(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))<_Params[\"PVCapacity\"].values[0]))\n        #expected cost saving for group 1 is given by share of own consumption times capacity times expected price plus electricity fed into the grid times FIT\n        costsaving[group1]=_ExpectedPrice[group1,t]*_Params[\"PVCapacity\"].values[0]*_Params[\"PVCons\"].values[0]+(1-_Params[\"PVCons\"].values[0])*(_FIT[str(_year)].values[0]+_Subsidy2)*_Params[\"PVCapacity\"].values[0]\n        #expected cost saving for group 2 is given by minimum between own consumption share times capacity times expected price and expected electricity consumption times expected price, plus the remaining capacity of the panel times FIT\n        costsaving[group2]=_ExpectedPrice[group2,t]*np.minimum(_Params[\"PVCons\"].values[0]*_Params[\"PVCapacity\"].values[0],_Powercost_f[group2]*np.power((1+_Trend[group2]),t))+(_FIT[str(_year)].values[0]+_Subsidy2)*(_Params[\"PVCapacity\"].values[0]-np.minimum(_Params[\"PVCons\"].values[0]*_Params[\"PVCapacity\"].values[0],_Powercost_f[group2]*np.power((1+_Trend[group2]),t)))\n        #expected cost saving for groups 3 and 4 is equal to FIT times capacity of the solar panel\n        costsaving[group3]=(_FIT[str(_year)].values[0]+_Subsidy2)*_Params[\"PVCapacity\"].values[0]\n        costsaving[group4]=(_FIT[str(_year)].values[0]+_Subsidy2)*_Params[\"PVCapacity\"].values[0]\n        #Discounted value of expected cost saving is added to cumulative expected revenue\n        _Revenue=_Revenue+costsaving/(np.power(1+_Discount,t))\n        #Expected interest cost\n        cost=proposedrate*balanceremaining\n        #Remaining loan balance\n        balanceremaining=balanceremaining-(payment-cost)\n        #Discounted interest cost is added to cumulative expected cost of the loan\n        _LoanCost=_LoanCost+cost/(np.power(1+_Discount,t))\n    #Expected profit from PV ownership is given by cumulative discounted expected revenue minus installation cost (possibly reduced by subsidy) minus cumulative expected discounted cost of the loan\n    profit=_Revenue-((1-_Subsidy1)*_Params[\"PanelCost\"].values[0])-_LoanCost\n    #For each agent, set variable deciles to the PV ownership rate in their own income decile\n    deciles=_PVOwnershipDeciles[_IncomeDeciles.astype(int)]\n    #Utility depends on profit, social influence component (deciles=share of other agents in decile who already have PV) and environmental attitude\n    utility=profit+_Influence*(deciles-(1-deciles))+_Params[\"Beta\"].values[0]*_Attitude\n    #Assume that agents who had already adopted PV before but whose panel has reached maximum age will only consider expected profit when deciding whether to re-adopt\n    utility[(_Adopted==1) & (_CumulativeProfit>0) & (_PV==0)]=profit\n    #Re-set cumulative profit for agents who made a loss over the lifetime of their panel to 0\n    _CumulativeProfit[(_Adopted==1) & (_CumulativeProfit<=0) & (_PV==0)]=0\n    #Agents who are credit rationed will not adopt\n    utility[_Rationed==1]=0\n    #Agents for whom PV is not technically feasible will not adopt\n    utility[_Feasible==0]=0\n    #Agents who already own PV will not adopt\n    utility[_PV==1]=0\n    #Find agents who will adopt\n    adopters=np.where(utility>0)\n    #Find adopters who need a loan\n    borrowers=np.where((utility>0) & (loanneeded>0))\n    #Set PV dummy for adopters to 1\n    _PV[adopters]=1\n    #Set FIT for adopters (will be unchanged over the lifetime of the panel!)\n    _PanelFIT[adopters]=_FIT[str(_year)].values[0]\n    #Indicates whether agent adopted PV at any point during the run; set to 1 for adopters\n    _Adopted[adopters]=1\n    #Re-initialise cumulative profit for adopters\n    _CumulativeProfit[adopters]=-((1-_Subsidy1)*_Params[\"PanelCost\"].values[0])\n    #Update liquidity for adopters, possibly including loan needed\n    _Liquidity[adopters]=_Liquidity[adopters]-((1-_Subsidy1)*_Params[\"PanelCost\"].values[0])+loanneeded[adopters]\n    #Set loan rate for borrowers\n    _LoanRate[borrowers]=proposedrate[borrowers]*loanneeded[borrowers]/(loanneeded[borrowers]+_Debt[borrowers])+_LoanRate[borrowers]*_Debt[borrowers]/(loanneeded[borrowers]+_Debt[borrowers])\n    #Set debt level and debt service payments for borrowers\n    _Debt[borrowers]=_Debt[borrowers]+loanneeded[borrowers]\n    _DebtService[borrowers]=_Debt[borrowers]*(_LoanRate[borrowers]*(np.power(1+_LoanRate[borrowers],_Params[\"PVMaxAge\"].values[0])))/((np.power(1+_LoanRate[borrowers],_Params[\"PVMaxAge\"].values[0]))-1)\n    return[_PV,_Rationed,_Liquidity,_LoanRate,_Debt,_DebtService,_Adopted,_CumulativeProfit,_PanelFIT]"
  },
  {
    "objectID": "05_code.html#pv-deciles",
    "href": "05_code.html#pv-deciles",
    "title": "Model Code",
    "section": "PV Deciles",
    "text": "PV Deciles\nThis function calculates the share of agents who own PV in each decile. It is called at the end of a simulation period and, because an initial value is needed for the adoption decision in the first simulation period, once after function IncomeGroups during the first simulation period. It determines the overall number of agents in each income decile as well as the number of agents owning PV in each decile in order to calculate a PV ownership rate for each decile.\n\ndef PVDeciles(_Income_p,_PV,_Positions_d,_Deciles,_PVOwnershipDeciles,_DecileMembers):\n    #Sort vector of income net of electricity cost in ascending order\n    income_psorted=np.sort(_Income_p)\n    #Based on sorted income and number of agents in each decile, set cut-off points\n    _Deciles[0:9]=income_psorted[_Positions_d]\n    _Deciles[9]=income_psorted[((income_psorted.size)-1)]\n    #Iterate over deciles\n    for i in range(10):\n        #Determine which agents belong to decile i\n        if i==0:\n            members=np.where(_Income_p<=_Deciles[i])\n        else:\n            members=np.where((_Income_p<=_Deciles[i]) & (_Income_p>_Deciles[(i-1)]))\n        #Set the number of agents in decile i\n        _DecileMembers[i]=members[0].size\n        #Set the number of agents owning PV in decile i\n        _PVOwnershipDeciles[i]=_PV[members[0]].sum()\n    #Calculate ownership rate by decile\n    _PVOwnershipDeciles=_PVOwnershipDeciles/_DecileMembers\n    return[_PVOwnershipDeciles]"
  },
  {
    "objectID": "05_code.html#calculate-statistics",
    "href": "05_code.html#calculate-statistics",
    "title": "Model Code",
    "section": "Calculate statistics",
    "text": "Calculate statistics\nThis function calculates a range of statistics, time-series of which will be returned by the main function at the end of a simulation.\n\ndef CalculateStatistics(_PV,_Income,_Debt,_Liquidity,_ExpectedPrice,_Feasible,_Rationed):\n    #Average income\n    averageincome=np.sum(_Income)/_Income.size\n    #Average Liquidity\n    averageliquidity=np.sum(_Liquidity)/_Liquidity.size\n    #Average expected price in t+1\n    averageexpectedprice=np.sum(_ExpectedPrice)/_ExpectedPrice.size\n    #Average debt, only taking into account agents with positive debt\n    if np.sum(_Debt>0)>0:\n        averagedebt=np.sum(_Debt[_Debt>0])/np.sum(_Debt>0)\n    else:\n        averagedebt=0\n    #Adoption rate taking into account all agents\n    adoptionrate1=np.sum(_PV)/_PV.size\n    #Adoption rate taking into account only agents for whom PV is technically feasible\n    if np.sum(_Feasible)>0:\n        adoptionrate2=np.sum(_PV)/np.sum(_Feasible)\n    else:\n        adoptionrate2=0\n    #Share of agents who are credit-rationed\n    if np.sum((_PV==0) & (_Feasible==1))>0:\n        rationing=np.sum(_Rationed)/np.sum((_PV==0) & (_Feasible==1))\n    else:\n        rationing=0\n    return(averageincome,averageliquidity,averageexpectedprice,averagedebt,adoptionrate1,adoptionrate2,rationing)"
  },
  {
    "objectID": "05_code.html#main-model-function",
    "href": "05_code.html#main-model-function",
    "title": "Model Code",
    "section": "Main model function",
    "text": "Main model function\nThis is the function which must be called to execute the model. It takes several inputs, namely:\n\n\ninputfile - a csv file containing a a list of all model households and their initial characteristics\npropensitiesfile - a csv file containing propensities to consume out of income by income percentile\nliquiditysharesfile - a csv file containing the shares of saving going into liquid assets by income percentile\nfitfile - a csv containing the value of the feed-in tariff for solar panels installed in each simulation year\ncostfile - a csv containing an annual time-series of installation cost of a solar panel\nratefile - a csv containing an annual time-series of central bank base interest rates\npricefile - a csv containing an annual time-series of electricity prices\nparamfile - a csv file containing the names and values of all model parameters\nseed - a seed for the pseudo-random number generator\nstart - the start year of the model simulation\nend - the end year of the model simulation\n\n\nThe function begins by setting the seed for the pseudo-random number generator, and then loads all necessary external input files. It then initialises the model by generating vectors/arrays of all model variables and setting initial values where necessary.\nSubsequently, there is a single call to GenerateElectricityPrice in order to generate a time-series of electricity prices for the current model run. Subsequently, one of the electricity price time-series is used to train the agents’ expectations formation algorithm. After this, the main simulation loop is entered. In each simulation period, the model calls the functions described above one after the other, updating the relevant model variables based on the outputs of each function.\nAt the end of the simulation run, the time-series of aggregate statistics to be returned are stacked into a single array and converted to a dataframe, which is then saved in csv format, with the seed number attached to the file name. Similarly, the time-series of PV adoption rates by income decile are saved in csv format, with the seed number attached to the file name.\n\ndef PVModel(inputfile=\"inputs.csv\",propensitiesfile=\"consumptionpropensities.csv\",liquiditysharesfile=\"liquidityshares.csv\",fitfile=\"FIT.csv\",costfile=\"pvcost.csv\",ratefile=\"baserate.csv\",pricefile=\"electricityprice.csv\",paramfile=\"parameters.csv\",seed=1,runname=\"test\",start=2018,end=2040):\n    #Set seed\n    np.random.seed(seed)\n    \n    #Load external input files\n    Inputs=pd.read_csv(inputfile)\n    Params=pd.read_csv(paramfile)\n    Propensities=np.ndarray.flatten(pd.read_csv(propensitiesfile,header=None).to_numpy())\n    LiquidityShares=np.ndarray.flatten(pd.read_csv(liquiditysharesfile,header=None).to_numpy())\n    FIT=pd.read_csv(fitfile)\n    PVCost=pd.read_csv(costfile)\n    Baserate=pd.read_csv(ratefile)\n    PriceEmp=pd.read_csv(pricefile)\n\n    #Initialise deterministic mean values for income\n    Income_f=np.ndarray.flatten(Inputs[[\"income\"]].to_numpy())\n    #Create matrix for actual income\n    Income=np.zeros(shape=(len(Inputs.index),(end-start+1)))\n    #Create matrix for income net of power cost\n    Income_p=np.zeros(shape=(len(Inputs.index),(end-start+1)))\n    #Set values for standard deviation of income\n    Income_sd=np.ndarray.flatten(Inputs[[\"incomesd\"]].to_numpy())\n    #Initialise deterministic values of electricity consumption\n    Powercost_f=np.ndarray.flatten(Inputs[[\"powercons\"]].to_numpy())\n    #Create matrix for actual power cost (including price)\n    Powercost=np.zeros(shape=(len(Inputs.index),(end-start+1)))\n    #Create vector for current consumption\n    Consumption=np.zeros(len(Inputs.index))\n    #Create matrix for liquidity and set initial values\n    Liquidity=np.zeros(shape=(len(Inputs.index),(end-start+1)))\n    Liquidity[:,0]=np.ndarray.flatten(Inputs[[\"liquidity\"]].to_numpy())\n    #Create vectors for debt, debt service payments and loan rates\n    Debt=np.zeros(len(Inputs.index))\n    DebtService=np.zeros(len(Inputs.index))\n    LoanRate=np.zeros(len(Inputs.index))\n\n    #Set trend rates at which electricity consumption and mean values of income will grow\n    Trend=np.ndarray.flatten(Inputs[[\"trend\"]].to_numpy())\n    #Set housing dummy (1=agent lives in house, 0=agent lives in flat)\n    House=np.ndarray.flatten(Inputs[[\"house\"]].to_numpy())\n    #Create matrix for current PV ownership dummies and set initial values (1=currently owns PV)\n    PV=np.zeros(shape=(len(Inputs.index),(end-start+1)))\n    PV[:,0]=np.ndarray.flatten(Inputs[[\"pv\"]].to_numpy())\n    #Initialise age of solar panels\n    PanelAge=np.ndarray.flatten(Inputs[[\"panelage\"]].to_numpy())\n    #Set environmental attitudes\n    Attitude=np.ndarray.flatten(Inputs[[\"attitude\"]].to_numpy())\n    #Set strength of social influence for each agent\n    Influence=np.random.uniform(0,1,len(Inputs.index))*(Params[\"MaxInfluence\"].values[0]-Params[\"MinInfluence\"].values[0])+Params[\"MinInfluence\"].values[0]\n    #Set discount rate for each agent\n    Discount=np.ndarray.flatten(Inputs[[\"discount\"]].to_numpy())\n    #Create vector of dummies indicating whether PV is technically feasible\n    Feasible=np.zeros(len(Inputs.index))\n    #If agent already owns PV, it is feasible\n    Feasible[PV[:,0]==1]=1\n    #If agent lives in house, it is feasible\n    Feasible[House==1]=1\n    #If agent lives in flat, PV is feasible with a certain probability\n    Feasible[(House==0) & (PV[:,0]==0)]=np.random.uniform(0,1,sum((House==0) & (PV[:,0]==0)))\n    Feasible[Feasible>=(1-Params[\"FeasibilityProb\"].values[0])]=1\n    Feasible[Feasible<(1-Params[\"FeasibilityProb\"].values[0])]=0\n    #Create vector to hold feed-in tariffs earned by each agent\n    PanelFIT=np.zeros(len(Inputs.index))\n    #Find the oldest existing panel\n    maxage=max(PanelAge)\n    for a in range(maxage+1):\n        #Set the adoption year\n        yearadopted=start-(a+1)\n        #If the adoption year is within the range of the time-series of FITs, set the FIT of all agents who adopted in that year to the appropriate value\n        if sum(str(yearadopted)==FIT.columns)==1:\n            PanelFIT[(PV[:,0]==1) & (PanelAge==a)]=FIT[str(yearadopted)].values[0]\n        #Otherwise, set the FIT to the earliest available value\n        else:\n            PanelFIT[(PV[:,0]==1) & (PanelAge==a)]=FIT.iloc[0,0]\n\n    #Set the cutoff points for income percentiles\n    Positions_p=np.zeros(99)\n    Positions_p[:]=np.array(range(1,100,1))*(len(Inputs.index)+1)/100-1\n    Positions_p=np.round(Positions_p)\n    Positions_p=Positions_p.astype(int)\n    #Create vector to hold income value associated with each percentile\n    Percentiles=np.zeros(100)\n    #Set the cutoff points for income deciles\n    Positions_d=np.zeros(9)\n    Positions_d[:]=np.array(range(1,10,1))*(len(Inputs.index)+1)/10-1\n    Positions_d=np.round(Positions_d)\n    Positions_d=Positions_d.astype(int)\n    #Create vector to hold income value associated with each decile\n    Deciles=np.zeros(10)\n    #Create vector to hold number of agents in each decile\n    DecileMembers=np.zeros(10)\n    #Create vector to hold PV ownership rate in each decile\n    PVOwnershipDeciles=np.zeros(10)\n    #Create vectors to hold the income deciles and percentiles of each agent\n    IncomeDeciles=np.zeros(len(Inputs.index))\n    IncomePercentiles=np.zeros(len(Inputs.index))\n\n    #Set the gain parameter used by each agent in the recursive least squares learning algorithm\n    Gain=np.random.uniform(0,1,len(Inputs.index))*(Params[\"MaxGain\"].values[0]-Params[\"MinGain\"].values[0])+Params[\"MinGain\"].values[0]\n    #Initialise agents' estimates of parameters and variance-covariance matrices\n    ARPars=np.array([[Params[\"ElectricityPriceTrend\"].values[0]],[Params[\"ElectricityPriceAR\"].values[0]]])\n    ARPars=[ARPars]*len(Inputs.index)\n    ARPars=np.array(ARPars)\n    ARMats=np.array([[Params[\"ElectricityPriceMat11\"].values[0],Params[\"ElectricityPriceMat12\"].values[0]],[Params[\"ElectricityPriceMat21\"].values[0],Params[\"ElectricityPriceMat22\"].values[0]]])\n    ARMats=[ARMats]*len(Inputs.index)\n    ARMats=np.array(ARMats)\n    #Create a matrix to hold agents' expected electricity prices\n    ExpectedPrice=np.zeros(shape=(len(Inputs.index),Params[\"PVMaxAge\"].values[0]))\n\n    #Initialise policy variables\n    #Subsidy on purchase price of panel\n    Subsidy1=0\n    #Additional subsidy on FIT\n    Subsidy2=0\n    #Change in maximum loan to value ratio\n    CreditPolicy1=0\n    #Change in maximum debt service to income ratio\n    CreditPolicy2=0\n\n    #Create vector to hold expected discounted cumulative revenue from owning PV\n    Revenue=np.zeros(len(Inputs.index))\n    #Create vector to hold expected discounted cumulative loan cost to purchase PV\n    LoanCost=np.zeros(len(Inputs.index))\n    #Create vector to hold dummies indicating whether agents are credit-rationed\n    Rationed=np.zeros(len(Inputs.index))\n    #Create vector to hold actual cumulative profit derived from owning PV\n    CumulativeProfit=np.zeros(len(Inputs.index))\n    #Create vector of dummies indicating whether agent has at any point owned PV\n    Adopted=np.zeros(len(Inputs.index))\n    #Set initial values for agents already owning PV at the start of the simulation\n    Adopted[PV[:,0]==1]=1\n    #To initialise the cumulative profit on pre-existing solar panels, we divide agents owning PV into 4 groups\n    #Group 1 contains agents who own PV, whose electricity consumption is greater than the capacity of the panel, and whose FIT is lower than the starting value of the electricity price\n    group1=np.where((PV[:,0]==1) & (Powercost_f>=Params[\"PVCapacity\"].values[0]) & ((PanelFIT+Subsidy2)<PriceEmp[str(start-1)].values[0]))\n    #Group 2 contains agents who own PV, whose electricity consumption is greater than the capacity of the panel, and whose FIT is higher than the starting value of the electricity price\n    group2=np.where((PV[:,0]==1) & (Powercost_f>=Params[\"PVCapacity\"].values[0]) & ((PanelFIT+Subsidy2)>=PriceEmp[str(start-1)].values[0]))\n    #Group 3 contains agents who own PV, whose electricity consumption is smaller than the capacity of the panel, and whose FIT is lower than the starting value of the electricity price\n    group3=np.where((PV[:,0]==1) & (Powercost_f<Params[\"PVCapacity\"].values[0]) & ((PanelFIT+Subsidy2)<PriceEmp[str(start-1)].values[0]))\n    #Group 4 contains agents who own PV, whose electricity consumption is lower than the capacity of the panel, and whose FIT is higher than the starting value of the electricity price\n    group4=np.where((PV[:,0]==1) & (Powercost_f<Params[\"PVCapacity\"].values[0]) & ((PanelFIT+Subsidy2)>=PriceEmp[str(start-1)].values[0]))\n    #Cumulative profit of agents in group 1 is initialised as share of own consumption times capacity of the panel times initial electricity price plus remaining capacity times FIT\n    CumulativeProfit[group1]=Params[\"PVCons\"].values[0]*Params[\"PVCapacity\"].values[0]*PriceEmp[str(start-1)].values[0]+(1-Params[\"PVCons\"].values[0])*Params[\"PVCapacity\"].values[0]*(PanelFIT[group1]+Subsidy2)\n    #Cumulative profit of agents in group 2 is initialised as capacity of panel times FIT\n    CumulativeProfit[group2]=Params[\"PVCapacity\"].values[0]*(PanelFIT[group2]+Subsidy2)\n    #Cumulative profit of agents in group 3 is initialised as minimum between share of own consumption times capacity of the panel and electricity consumption times initial electricity price plus remaining capacity times FIT\n    CumulativeProfit[group3]=np.minimum(Params[\"PVCons\"].values[0]*Params[\"PVCapacity\"].values[0],Powercost_f[group3])*PriceEmp[str(start-1)].values[0]+(PanelFIT[group3]+Subsidy2)*(Params[\"PVCapacity\"].values[0]-np.minimum(Params[\"PVCons\"].values[0]*Params[\"PVCapacity\"].values[0],Powercost_f[group3]))\n    #Cumulative profit of agents in group 4 is initialised as capacity of panel times FIT\n    CumulativeProfit[group4]=Params[\"PVCapacity\"].values[0]*(PanelFIT[group4]+Subsidy2)\n    #For simplicity, assume that agents earned this profit in all previous periods\n    CumulativeProfit=CumulativeProfit*PanelAge\n    #Subtract from cumulative profit the cost of PV from the year in which it was installed\n    for a in range(maxage+1):\n        yearadopted=start-(a+1)\n        if sum(str(yearadopted)==PVCost.columns)==1:\n            CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]=CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]-(1-Subsidy1)*PVCost[str(yearadopted)].values[0]\n        #If a panel is older than the earliest available value for panel cost, use the earliest value\n        else:\n            CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]=CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]-(1-Subsidy1)*PVCost.iloc[0,0]\n\n\n    #Initialise aggregate statistics\n    AverageIncome=np.zeros((end-start+1))\n    AverageLiquidity=np.zeros((end-start+1))\n    AverageExpectedPrice=np.zeros((end-start+1))\n    AverageDebt=np.zeros((end-start+1))\n    AdoptionRate1=np.zeros((end-start+1))\n    AdoptionRate2=np.zeros((end-start+1))\n    AdoptionRateDeciles=np.zeros(((end-start+1),10))\n    ChangeAdoptionRate1=np.zeros((end-start+1))\n    ChangeAdoptionRate2=np.zeros((end-start+1))\n    RationedShare=np.zeros((end-start+1))\n\n    #Generate two electricity price time-series\n    PriceReturn=GenerateElectricityPrice(_PriceEmp=PriceEmp.copy(),_Params=Params.copy(),_length=(end-start+3),_start=start)\n    #Price series to be used in the simulation\n    Price=PriceReturn[0]\n    #Price series used to train agents' expectations formation\n    PriceTrain=PriceReturn[1]\n    #Use PriceTrain to train agents' expectations formation using a number of time-steps equal to the length of the actual simulation\n    for period in range((end-start+1)):\n        ExpectationReturn=FormExpectation(_ARPars=ARPars.copy(),_ARMats=ARMats.copy(),_Price=PriceTrain.copy(),_Gain=Gain.copy(),_ExpectedPrice=ExpectedPrice.copy(),_period=period)\n        ARMats=ExpectationReturn[0]\n        ARPars=ExpectationReturn[1]\n        ExpectedPrice=ExpectationReturn[2]\n    \n    #Enter main model loop\n    #Set the current year to the start year supplied to the function\n    year=start\n    for period in range((end-start+1)):\n        #Set the purchase and installation cost of a solar panel equal to the value for the current year\n        Params[\"PanelCost\"]=PVCost[str(year)].values[0]\n        #Set starting value for liquid wealth and PV equal to closing value from last period\n        if period>0:\n            Liquidity[:,period]=Liquidity[:,(period-1)]\n            PV[:,period]=PV[:,(period-1)]\n        #Set policy variables\n        PolicyReturn=SetPolicy(_Subsidy1=Subsidy1,_Subsidy2=Subsidy2,_CreditPolicy1=CreditPolicy1,_CreditPolicy2=CreditPolicy2,_year=year,_Params=Params.copy())\n        Subsidy1=PolicyReturn[0]\n        Subsidy2=PolicyReturn[1]\n        CreditPolicy1=PolicyReturn[2]\n        CreditPolicy2=PolicyReturn[3]\n        #Calculate income and electricity cost\n        IncomePowercostReturn=IncomePowercost(_Income_f=Income_f.copy(),_Trend=Trend.copy(),_Powercost_f=Powercost_f.copy(),_Income_sd=Income_sd.copy(),_CumulativeProfit=CumulativeProfit.copy(),_PV=PV[:,period].copy(),_Price=Price[(period+2)].copy(),_PanelFIT=PanelFIT.copy(),_Subsidy2=Subsidy2,_Params=Params.copy())\n        Income[:,period]=IncomePowercostReturn[0]\n        Powercost[:,period]=IncomePowercostReturn[1]\n        Income_p[:,period]=IncomePowercostReturn[2]\n        CumulativeProfit[:]=IncomePowercostReturn[3]\n        Income_f[:]=IncomePowercostReturn[4]\n        Powercost_f[:]=IncomePowercostReturn[5]\n        #Calculate income distribution statistics\n        IncomeGroupReturn=IncomeGroups(_Income_p=Income_p[:,period].copy(),_Positions_p=Positions_p.copy(),_Percentiles=Percentiles.copy(),_Positions_d=Positions_d.copy(),_Deciles=Deciles.copy(),_IncomePercentiles=IncomePercentiles.copy(),_IncomeDeciles=IncomeDeciles.copy())\n        IncomePercentiles[:]=IncomeGroupReturn[0]\n        IncomeDeciles[:]=IncomeGroupReturn[1]\n        #In first simulation period, initialise PV ownership by decile\n        if period==0:\n            PVDecileReturn=PVDeciles(_Income_p=Income_p[:,period].copy(),_PV=PV[:,period].copy(),_Positions_d=Positions_d.copy(),_PVOwnershipDeciles=PVOwnershipDeciles.copy(),_Deciles=Deciles.copy(),_DecileMembers=DecileMembers.copy())\n            PVOwnershipDeciles[:]=PVDecileReturn[0]\n        #Calculate consumption and saving\n        ConsumptionSavingReturn=ConsumptionSaving(_Income_p=Income_p[:,period].copy(),_Propensities=Propensities.copy(),_IncomePercentiles=IncomePercentiles.copy(),_Consumption=Consumption.copy(),_Income=Income[:,period].copy(),_Powercost=Powercost[:,period].copy(),_Liquidity=Liquidity[:,period].copy(),_Debt=Debt.copy(),_DebtService=DebtService.copy(),_LoanRate=LoanRate.copy(),_PanelAge=PanelAge.copy(),_CumulativeProfit=CumulativeProfit.copy(),_LiquidityShares=LiquidityShares.copy(),_Params=Params.copy(),_period=period)\n        Liquidity[:,period]=ConsumptionSavingReturn[0]\n        Debt[:]=ConsumptionSavingReturn[1]\n        DebtService[:]=ConsumptionSavingReturn[2]\n        LoanRate[:]=ConsumptionSavingReturn[3]\n        Consumption[:]=ConsumptionSavingReturn[4]\n        CumulativeProfit[:]=ConsumptionSavingReturn[5]\n        #Increment age of existing panels\n        PanelAgeReturn=AugmentPanelAge(_PV=PV[:,period].copy(),_PanelAge=PanelAge.copy(),_PanelFIT=PanelFIT.copy(),_Params=Params.copy())\n        PanelAge=PanelAgeReturn[0]\n        PV[:,period]=PanelAgeReturn[1]\n        PanelFIT=PanelAgeReturn[2]\n        #Form expectations\n        ExpectationReturn=FormExpectation(_ARPars=ARPars.copy(),_ARMats=ARMats.copy(),_Price=Price.copy(),_Gain=Gain.copy(),_ExpectedPrice=ExpectedPrice.copy(),_period=period)\n        ARMats=ExpectationReturn[0]\n        ARPars=ExpectationReturn[1]\n        ExpectedPrice=ExpectationReturn[2]\n        #Adoption decision\n        AdoptionReturn=AdoptionDecision(_PV=PV[:,period].copy(),_Feasible=Feasible.copy(),_Liquidity=Liquidity[:,period].copy(),_Rationed=Rationed.copy(),_Debt=Debt.copy(),_Income=Income[:,period].copy(),_Income_f=Income_f.copy(),_Powercost_f=Powercost_f.copy(),_Trend=Trend.copy(),_ExpectedPrice=ExpectedPrice.copy(),_Discount=Discount.copy(),_Revenue=Revenue.copy(),_LoanCost=LoanCost.copy(),_PVOwnershipDeciles=PVOwnershipDeciles.copy(),_IncomeDeciles=IncomeDeciles.copy(),_LoanRate=LoanRate.copy(),_DebtService=DebtService.copy(),_Influence=Influence.copy(),_Attitude=Attitude.copy(),_Adopted=Adopted.copy(),_CumulativeProfit=CumulativeProfit.copy(),_FIT=FIT.copy(),_year=year,_PanelFIT=PanelFIT.copy(),_Baserate=Baserate.copy(),_Subsidy1=Subsidy1,_Subsidy2=Subsidy2,_CreditPolicy1=CreditPolicy1,_CreditPolicy2=CreditPolicy2,_Params=Params.copy())\n        PV[:,period]=AdoptionReturn[0]\n        Rationed[:]=AdoptionReturn[1]\n        Liquidity[:,period]=AdoptionReturn[2]\n        LoanRate[:]=AdoptionReturn[3]\n        Debt[:]=AdoptionReturn[4]\n        DebtService[:]=AdoptionReturn[5]\n        Adopted[:]=AdoptionReturn[6]\n        CumulativeProfit[:]=AdoptionReturn[7]\n        PanelFIT[:]=AdoptionReturn[8]\n        #Calculate aggregate statistics\n        StatisticsReturn=CalculateStatistics(_PV=PV[:,period].copy(),_Income=Income[:,period].copy(),_Debt=Debt.copy(),_Liquidity=Liquidity[:,period].copy(),_ExpectedPrice=ExpectedPrice[:,0].copy(),_Feasible=Feasible.copy(),_Rationed=Rationed.copy())\n        AverageIncome[period]=StatisticsReturn[0]\n        AverageLiquidity[period]=StatisticsReturn[1]\n        AverageExpectedPrice[period]=StatisticsReturn[2]\n        AverageDebt[period]=StatisticsReturn[3]\n        AdoptionRate1[period]=StatisticsReturn[4]\n        AdoptionRate2[period]=StatisticsReturn[5]\n        RationedShare[period]=StatisticsReturn[6]\n        #Calculate change in adoption rates\n        if period>0:\n            ChangeAdoptionRate1[period]=AdoptionRate1[period]-AdoptionRate1[(period-1)]\n            ChangeAdoptionRate2[period]=AdoptionRate2[period]-AdoptionRate2[(period-1)]\n        #Calculate PV ownership rate by decile    \n        PVDecileReturn=PVDeciles(_Income_p=Income_p[:,period].copy(),_PV=PV[:,period].copy(),_Positions_d=Positions_d.copy(),_PVOwnershipDeciles=PVOwnershipDeciles.copy(),_Deciles=Deciles.copy(),_DecileMembers=DecileMembers.copy())\n        PVOwnershipDeciles[:]=PVDecileReturn[0]\n        AdoptionRateDeciles[period]=PVOwnershipDeciles\n        #Increment year\n        year=year+1\n\n    #Save aggregate statistics and ownership rates by decile\n    Stats=np.column_stack((AverageIncome,AverageLiquidity,AverageExpectedPrice,AverageDebt,AdoptionRate1,AdoptionRate2,ChangeAdoptionRate1,ChangeAdoptionRate2,RationedShare,Price[2:len(Price)]))\n    Stats=pd.DataFrame(data=Stats,columns=[\"AverageIncome\",\"AverageLiquidity\",\"AverageExpectedPrice\",\"AverageDebt\",\"AdoptionRate1\",\"AdoptionRate2\",\"ChangeAdoptionRate1\",\"ChangeAdoptionRate2\",\"RationedShare\",\"Price\"])\n    Stats_m=pd.DataFrame(data=AdoptionRateDeciles,columns=[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"])\n    filename='outputSolar/out_'\n    filename+=runname\n    filename+=\"_\"\n    filename+=str(seed)\n    filename+='.csv'\n    filename2='outputSolar/out_deciles_'\n    filename2+=runname\n    filename2+=\"_\"\n    filename2+=str(seed)\n    filename2+='.csv'\n    Stats.to_csv(filename)\n    Stats_m.to_csv(filename2)"
  },
  {
    "objectID": "06_modelresults.html",
    "href": "06_modelresults.html",
    "title": "Model Results",
    "section": "",
    "text": "To run the model locally, four csv files, namely inputs.csv, consumptionpropensities.csv, liquidityshares.csv and parameters.csv are needed. Paths to these files must be supplied as arguments to the main model function, along with a seed (positive integer) and a desired start and end year of the simulation.\nBelow we run the model by calling Python through R’s system function and making Python execute the runModel.py script which calls the main model function, passing it the appropriate input files, the start and end years (we choose 2018 and 2040 here) as well as the seed (1) which we feed through the command line.\n\ncommand<-paste(\"python \", gsub(\"WebsiteABM\", \"\", getwd()),\"06_ModelCode/runModel.py 1\",sep = \"\")\nt<-system(command)\n\nThis one-off simulation of the model for a single seed will create one output csv file called out_1.csv (where 1 denotes the seed associated with the run). This file can then be loaded in order to plot results."
  },
  {
    "objectID": "06_modelresults.html#plotting-results",
    "href": "06_modelresults.html#plotting-results",
    "title": "Model Results",
    "section": "Plotting results",
    "text": "Plotting results\n\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(conflicted)\nconflict_prefer(\"melt\",\"reshape2\")\noutputfile<-paste(gsub(\"WebsiteABM\", \"\", getwd()),\"07_ModelOutput/out_1.csv\",sep = \"\")\noutput<-read.csv(outputfile,header = TRUE)\n\n\nplotdata<-as.data.frame(cbind(output$AdoptionRate1,output$AdoptionRate2,c(2018:2040)))\ncolnames(plotdata)<-c(\"Rate1\",\"Rate2\",\"Year\")\nplotdata<-melt(plotdata,id = \"Year\")\nggplot(plotdata,aes(x=Year,y=value,colour=variable,group=variable)) + geom_line(lwd=1) +labs(y= \"Ownership rate\")+theme_bw()+ ggtitle(\"Simulated PV ownership rates\")+theme(legend.title=element_blank())+ scale_colour_discrete(labels=c('All', 'Only feasible'))\n\n\n\n\n\nplotdata<-as.data.frame(cbind(output$ChangeAdoptionRate1[2:23],output$ChangeAdoptionRate2[2:23],c(2019:2040)))\ncolnames(plotdata)<-c(\"Rate1\",\"Rate2\",\"Year\")\nplotdata<-melt(plotdata,id = \"Year\")\nggplot(plotdata,aes(x=Year,y=value,colour=variable,group=variable)) + geom_line(lwd=1) +labs(y= \"Change in ownership rate\")+theme_bw()+ ggtitle(\"Change in simulated PV ownership rates\")+theme(legend.title=element_blank())+ scale_colour_discrete(labels=c('All', 'Only feasible'))\n\n\n\n\n\nplotdata<-as.data.frame(cbind(output$Price[2:23],output$AverageExpectedPrice[1:22],c(2019:2040)))\ncolnames(plotdata)<-c(\"p1\",\"p2\",\"Year\")\nplotdata<-melt(plotdata,id = \"Year\")\nggplot(plotdata,aes(x=Year,y=value,colour=variable,group=variable)) + geom_line(lwd=1) +labs(y= \"Price\")+theme_bw()+ ggtitle(\"Effective and average expected simulated electricity prices\")+theme(legend.title=element_blank())+ scale_colour_discrete(labels=c('Actual', 'Expected'))\n\n\n\n\n\nplotdata<-as.data.frame(cbind(output$RationedShare,c(2018:2040)))\ncolnames(plotdata)<-c(\"s1\",\"Year\")\nplotdata<-melt(plotdata,id = \"Year\")\nggplot(plotdata,aes(x=Year,y=value,colour=variable,group=variable)) + geom_line(lwd=1) +labs(y= \"Share\")+theme_bw()+ ggtitle(\"Share of potential adopters who are credit rationed\")+theme(legend.position = \"none\")"
  }
]