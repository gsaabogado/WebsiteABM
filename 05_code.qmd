---
title: "Model Code"
author: "Severin Reissl and Luis Sarmiento"
format: 
  html: 
    toc: true
    warning: false
    code-fold: false
editor: visual
jupyter: python3
---

The model is written in Python. Below we provide a step-by-step documentation of all model functions. In total the model consists of 10 separate functions, which are in turn called by one main model function containing the initialisation and the main simulation loop. This main function is described last.


## Generate Electricity Price

This function is called once at the beginning of a simulation run in order to generate a time-series of the electricity price which agents have to pay at each time-step of the simulation (note that this is different from the expected future electricity price, described below). 

The function takes four inputs. `_PriceEmp` is a pandas dataframe containing an empirical time-series of the electricity price. `_Params`, is a pandas dataframe containing the names and values of the model parameters.  `_length`, is an integer denoting the length of the time-series to be created (given by simulation length+2 since we need two lagged values at the beginning for the expectations formation process discussed below). Finally, `_start` denotes the start year of the simulation

The function then creates two numpy vectors of zeros of size `_length`. `electricityprice1` is the vector of prices that will actually be used in the simulation. `electricityprice2` instead is a vector of prices which will be used to train the agents' expectations formation mechanism prior to the beginning of the simulation.

The first two elements of the vectors are set to the empirical values of the electricity price in `_start-2` and `_start-1`. The rest of the vector `electricityprice1` is then filled either with empirical values of the price (if these are available, e.g. because we are simulating past years rather than the future) or by  iterating forward an AR(1) model previously estimated on the empirical price data, including a normally distributed random shock the standard deviation of which is taken from the standard deviation of the residuals from the estimation of the AR(1) model. `electricityprice2`, the "training set", is filled completely with simulated values from the AR(1) model.
Finally, the function returns the two time-series of the electricity price.

```{python}
def GenerateElectricityPrice(_PriceEmp,_Params,_length,_start):
    #Create vectors of zeros
    electricityprice1=np.zeros(_length)
    electricityprice2=np.zeros(_length)
    #Set first two elements to empirical electricity price in _start-2 and _start-1
    electricityprice1[0]=_PriceEmp[str(_start-2)].values[0]
    electricityprice2[0]=_PriceEmp[str(_start-2)].values[0]
    electricityprice1[1]=_PriceEmp[str(_start-1)].values[0]
    electricityprice2[1]=_PriceEmp[str(_start-1)].values[0]
    #Iterate over rest of vector
    for t in range(2,_length):
        #If the empirical price-series still contains values, use them to fill electricityprice1
        if sum(str(_start-2+t)==_PriceEmp.columns)==1:
            electricityprice1[t]=_PriceEmp[str(_start-2+t)].values[0]
        else:
        #Otherwise, fill the rest of electricityprice1 with simulated prices using a previously estimated AR1 model
            #Generate normally distributed shock based on standard deviation of regression residuals
            shock1=_Params["ElectricityPriceSD"].values[0]*np.sqrt(-2*np.log(np.random.uniform(0,1,1)))*np.cos(2*np.pi*np.random.uniform(0,1,1))
            #Price in t calculated by iterating AR(1) model
            electricityprice1[t]=electricityprice1[t-1]+_Params["ElectricityPriceTrend"].values[0]+_Params["ElectricityPriceAR"].values[0]*(electricityprice1[t-1]-electricityprice1[t-2])+shock1 
        #electricityprice2, which is used to train the expectations formation mechanism, is filled completely with simulated values
        #Generate normally distributed shock based on standard deviation of regression residuals
        shock2=_Params["ElectricityPriceSD"].values[0]*np.sqrt(-2*np.log(np.random.uniform(0,1,1)))*np.cos(2*np.pi*np.random.uniform(0,1,1))
        #Price in t calculated by iterating AR(1) model
        electricityprice2[t]=electricityprice2[t-1]+_Params["ElectricityPriceTrend"].values[0]+_Params["ElectricityPriceAR"].values[0]*(electricityprice2[t-1]-electricityprice2[t-2])+shock2
    return [electricityprice1,electricityprice2]
```

## Set Policy

Depending on the values of various dummies in the `_Params` dataframe and the current simulation period `_year`, this function determines whether a policy experiment should be activated in the current period.

At present, the model includes four possible policies, namely a subsidy on the cost of a solar panel (`Subsidy1`), a subsidy on the price at which electricity generated by PV can be sold to the grid (`Subsidy2`), a policy increasing the maximum permitted loan to value ratio for bank loans to acquire PV (`CreditPolicy1`, currently not used since in the baseline the maximum LTV is already set to 1), and a policy increasing the maximum allowed debt service to income ratio resulting from a loan made to acquire PV (`CreditPolicy2`). For instance, if the dummy `_Subsidy1` is set to 1 and if the current simulation period (expressed as a year) is equal to or larger than `SubsidyStart`, a subsidy on the installation cost of PV will be activated. The function checks the conditions for the respective policy variables in each period, changes them if necessary, and then returns them.

```{python}
def SetPolicy(_Subsidy1,_Subsidy2,_CreditPolicy1,_CreditPolicy2,_year,_Params):
    if _Params["Subsidy1"].values[0]==1 & _year>=_Params["SubsidyStart"].values[0]:
        _Subsidy1=_Params["s1"].values[0]
    if _Params["Subsidy2"].values[0]==1 & _year>=_Params["SubsidyStart"].values[0]:
        _Subsidy2=_Params["s2"].values[0]
    if _Params["CreditPolicy1"].values[0]==1 & _year>=_Params["CreditPolicyStart"].values[0]:
        _CreditPolicy1=_Params["cp1"].values[0]
    if _Params["CreditPolicy2"].values[0]==1 & _year>=_Params["CreditPolicyStart"].values[0]:
        _CreditPolicy2=_Params["cp2"].values[0]
    return[_Subsidy1,_Subsidy2,_CreditPolicy1,_CreditPolicy2]
```

## Income and Power cost

This function generates the incomes and electricity costs for each agent in every period. `_Income_f` and `_Powercost_f` are vectors of length *N*, where *N* is the number of agents in the model. The deterministic values of income and power cost for each agent are assumed to grow at rate `_Trend` (which may be heterogeneous across agents but is currently uniform) at each time step. 
The electricity cost to be paid by each agent is deterministic, while their income in the current period is drawn from a normal distribution with mean `_Income_f` and standard deviation `_Income_sd`.

Having determined income and power cost for each agent, we move on to calculate the revenue/cost saving generated by solar panels in the current period. We begin by setting `panelrevenue` as a copy of `_PV`, a vector of dummies indicating whether an agent owns PV in the current period. Hence `panelrevenue` is zero (and will remain zero in the calculations below) for agents who do not own PV.

We then calculate `panelrevenue` for the agents who do own PV, by dividing them into 4 groups depending on whether their own electricity consumption in the current period is larger or smaller than the capacity of the solar panel and whether their feed-in tariff (FIT; possibly including an additional subsidy if one is in force, see the function above) is higher or lower than the current electricity price (note that, as in reality in Germany, the feed-in tariff depends on the year in which the PV was installed and remains constant thereafter, meaning that agents will receive different FITs depending on how old their panel is). `panelrevenue` is then set for each of the four groups, assuming that agents can consume a maximum of  `_Params["PVCons"].values[0]` of the amount of electricity generated by the panel.

The electricity cost of agents owning PV is then reduced by `panelrevenue` (note that this can lead to cases in which electricity cost becomes smaller than 0 when the revenue from the panel exceeds electricity cost). In addition, `_CumulativeProfit`, which keeps track of the profit which PV owners have derived from their panel over its lifetime, is updated. Finally, we calculate a measure of income net of electricity cost which is used below to calculate income distribution statistics.


```{python}
def IncomePowercost(_Income_f,_Trend,_Powercost_f,_Income_sd,_CumulativeProfit,_PV,_Price,_PanelFIT,_Subsidy2,_Params):
    #Deterministic income and power cost values grow at exogenous trend
    _Income_f=_Income_f*(1+_Trend)
    _Powercost_f=_Powercost_f*(1+_Trend)
    #Actual income is drawn from a normal distribution with mean _Income_f and standard deviation _Income_sd
    randincome=np.random.uniform(0,1,_Income_f.size)
    randincome2=np.random.uniform(0,1,_Income_f.size)
    randincome=np.sqrt(-2*np.log(randincome))*np.cos(2*np.pi*randincome2)
    randincome=_Income_sd*randincome*_Income_f+_Income_f
    randincome=np.maximum(1e-10,randincome)
    #Power cost is multiplied by current electricity price
    powercost=_Powercost_f*_Price
    #Calculate revenue/cost saving generated by existing solar panels in the current period. Note that if _PV=0, panelrevenue=0
    panelrevenue=_PV.copy()
    #Agents who own PV, whose electricity consumption exceeds the capacity of the panel and whose FIT is smaller than the current electricity price
    group1=np.where((_PV==1) & (_Powercost_f>=_Params["PVCapacity"].values[0]) & ((_PanelFIT+_Subsidy2)<_Price))
    #Agents who own PV, whose electricity consumption exceeds the capacity of the panel and whose FIT is larger than the current electricity price
    group2=np.where((_PV==1) & (_Powercost_f>=_Params["PVCapacity"].values[0]) & ((_PanelFIT+_Subsidy2)>=_Price))
    #Agents who own PV, whose electricity consumption is smaller than the capacity of the panel and whose FIT is smaller than the current electricity price
    group3=np.where((_PV==1) & (_Powercost_f<_Params["PVCapacity"].values[0]) & ((_PanelFIT+_Subsidy2)<_Price))
    #Agents who own PV, whose electricity consumption is smaller than the capacity of the panel and whose FIT is larger than the current electricity price
    group4=np.where((_PV==1) & (_Powercost_f<_Params["PVCapacity"].values[0]) & ((_PanelFIT+_Subsidy2)>=_Price))
    #Revenue of group 1 is given by share of own consumption times capacity times price plus electricity fed into the grid times FIT
    panelrevenue[group1]=_Params["PVCons"].values[0]*_Params["PVCapacity"].values[0]*_Price+(1-_Params["PVCons"].values[0])*_Params["PVCapacity"].values[0]*(_PanelFIT[group1]+_Subsidy2)
    #Revenue of group 2 is given by capacity times FIT
    panelrevenue[group2]=_Params["PVCapacity"].values[0]*(_PanelFIT[group2]+_Subsidy2)
    #Revenue of group 3 is given by minimum between own consumption share times capacity times price and electricity consumption times price, plus the remaining capacity of the panel times FIT
    panelrevenue[group3]=np.minimum(_Params["PVCons"].values[0]*_Params["PVCapacity"].values[0],_Powercost_f[group3])*_Price+(_PanelFIT[group3]+_Subsidy2)*(_Params["PVCapacity"].values[0]-np.minimum(_Params["PVCons"].values[0]*_Params["PVCapacity"].values[0],_Powercost_f[group3]))
    #Revenue of group 4 is given by capacity times FIT
    panelrevenue[group4]=_Params["PVCapacity"].values[0]*(_PanelFIT[group4]+_Subsidy2)
    #Reduce electricity cost by the revenue/cost saving generated by solar panels
    powercost=powercost-panelrevenue
    #Update cumulative profit of PV owners
    _CumulativeProfit[_PV==1]=_CumulativeProfit[_PV==1]+panelrevenue[_PV==1]
    #Calculate income net of power cost
    income_p=randincome-powercost
    income_p=np.maximum(0,income_p)
    return[randincome,powercost,income_p,_CumulativeProfit,_Income_f,_Powercost_f]
```


## Income Groups

The purpose of this function is to calculate income distribution statistics, as well as the rates of PV ownership by income decile, which are used in other parts of the model. We begin by sorting `_Income_p`, the vector containing income net of electricity cost, in ascending order. Next, we set the cut-off points for income deciles and percentiles using the vectors `_Positions_p` and `_Positions_d`, which are calculated during the initialisation phase (described below) based on the number of agents in the model and give the number of agents in each decile/percentile. Next we iterate over all deciles and percentiles, assinging to each agent their income decile/percentile based on their current income net of electricity cost.

The function returns `_IncomePercentiles` and `_IncomeDeciles`, two vectors of length *N*, in which each element gives the income percentile/decile of the respective agent.


```{python}
def IncomeGroups(_Income_p,_Positions_p,_Percentiles,_Positions_d,_Deciles,_IncomePercentiles,_IncomeDeciles):
    #Sort income net of electricity cost in ascending order
    income_psorted=np.sort(_Income_p)
    #Based on sorted income and number of agents in each decile/percentile, set cut-off points
    _Percentiles[0:99]=income_psorted[_Positions_p]
    _Percentiles[99]=income_psorted[((income_psorted.size)-1)]
    _Deciles[0:9]=income_psorted[_Positions_d]
    _Deciles[9]=income_psorted[((income_psorted.size)-1)]
    #Iterate over deciles
    for i in range(10):
        #Determine which agents belong to decile i
        if i==0:
            members=np.where(_Income_p<=_Deciles[i])
        else:
            members=np.where((_Income_p<=_Deciles[i]) & (_Income_p>_Deciles[(i-1)]))
        #Set decile of all members to i
        _IncomeDeciles[members]=i
    #Iterate over percentiles
    for i in range(100):
        #Determine which agents belong to percentile i
        if i==0:
            members=np.where(_Income_p<=_Percentiles[i])
        else:
            members=np.where((_Income_p<=_Percentiles[i]) & (_Income_p>_Percentiles[(i-1)]))
        #Set percentile of all members to i
        _IncomePercentiles[members]=i
    return[_IncomePercentiles,_IncomeDeciles]
```

## Consumption and saving

This function determines agents' consumption and saving. In addition, agents with positive outstanding debt make debt service payments. The main purpose of this is to update agents' `_Liquidity` , i.e. their stock of liquid assets (money) which can be used to buy PV.

The function begins by setting a consumption propensity out of income net of electricity cost for each agent based on their current income percentile. From this, their desired consumption is determined, including a persistence component. Income, electricity cost and desired consumption are then used to calculate the desired saving of each agent. If an agent cannot finance their desired consumption and electricity cost using current income and accumulated liquid assets, their actual consumption is implicitly curtailed such that their liquidity does not become negative (since we assume that households cannot borrow for consumption but only to acquire PV).

Next, agents with positive debt make debt service payments, which are divided into principal payments (which reduce the stock of outstanding debt) and interest payments. Any interest payments which agents cannot afford are added to their balance of outstanding debt and their debt service payments for the following periods are updated accordingly. Agents whose debt has become zero in the current period (i.e. they have paid off their full loan) have their interest rate and debt service payments set to zero. `_CumulativeProfit`, which keeps track of the profit/cost saving which PV owners have derived from their solar panel is updated using interest payments made.

Finally, if an agent has positive saving after debt service in the current period, their liquidity is updated by a fraction of that increment. This fraction is based on the agent's current income decile and reflects the share of financial wealth held as liquid assets by income group.

The function returns agents' updated current liquidity, debt, debt service payments, loan interest rates and *desired* consumption (the latter is used in the next period to calculate the persistence component of desired consumption).

```{python}
def ConsumptionSaving(_Income_p,_Propensities,_IncomePercentiles,_Consumption,_Income,_Powercost,_Liquidity,_Debt,_DebtService,_LoanRate,_PanelAge,_CumulativeProfit,_LiquidityShares,_Params,_period):
    #Determine agents' consumption propensities out of income net of electricity cost based on their current income percentile
    consshares=_Propensities[_IncomePercentiles.astype(int)]
    #Determine desired consumption
    if _period==0:
        _Consumption[:]=consshares*_Income_p
    else:
        #If simulation period>0, take into account persistence in desired consumption
        _Consumption[:]=_Params["PersistenceConsumption"].values[0]*_Consumption[:]+(1-_Params["PersistenceConsumption"].values[0])*consshares*_Income_p
    #Agents' desired saving is gross income minus (desired) consumption minus electricity cost
    saving=_Income-_Consumption-_Powercost
    #Save pre-consumption liquidity (stock of money) of each agent
    Liquidity_p=_Liquidity.copy()
    #If liquidity and income are greater than consumption plus electricity cost, update liquidity using saving (which may be negative!)
    _Liquidity[(Liquidity_p+_Income)>=(_Consumption+_Powercost)]=_Liquidity[(Liquidity_p+_Income)>=(_Consumption+_Powercost)]+saving[(Liquidity_p+_Income)>=(_Consumption+_Powercost)]
    #Otherwise, liquidity is set to 0; consumption is implicitly reduced to ensure liquidity does not become negative
    _Liquidity[(Liquidity_p+_Income)<(_Consumption+_Powercost)]=0
    #Determine debt service for agents with positive debt
    _DebtService[_Debt>0]=np.minimum(_DebtService[_Debt>0],_Debt[_Debt>0])
    #Decompose debt service into interest and principal component
    interest=_LoanRate*_Debt
    principal=_DebtService-interest
    #Update remaining term of loan
    term=np.maximum(1,_Params["PVMaxAge"].values[0]-_PanelAge)
    #Principal is paid if agent can afford to do so; debt is reduced
    _Debt[_Liquidity>=_DebtService]=_Debt[_Liquidity>=_DebtService]-principal[_Liquidity>=_DebtService]
    #Agents who cannot afford full principal pay as much as they can
    _Debt[(_Liquidity>=interest) & (_Liquidity<_DebtService)]=_Debt[(_Liquidity>=interest) & (_Liquidity<_DebtService)]-_Liquidity[(_Liquidity>=interest) & (_Liquidity<_DebtService)]
    #Any unpaid interest is added to outstanding debt
    _Debt[_Liquidity<interest]=_Debt[_Liquidity<interest]+interest[_Liquidity<interest]-_Liquidity[_Liquidity<interest]
    #Update cumulative profit of PV owners by interested paid on loans to acquire PV
    interest[_Liquidity<interest]=interest[_Liquidity<interest]-_Liquidity[_Liquidity<interest]
    _CumulativeProfit=_CumulativeProfit-interest
    #Find agents who did not fully service debt
    adjustservice=np.where(_Liquidity<_DebtService)
     #Update liquidity based on debt service made
    Liquidity_pd=_Liquidity.copy()
    _Liquidity[Liquidity_pd<_DebtService]=0
    _Liquidity[Liquidity_pd>=_DebtService]=_Liquidity[Liquidity_pd>=_DebtService]-_DebtService[Liquidity_pd>=_DebtService]
    #Adjust debt service of agents who did not pay full debt service
    _DebtService[adjustservice]=_Debt[adjustservice]*(_LoanRate[adjustservice]*np.power((1+_LoanRate[adjustservice]),term[adjustservice]))/(np.power((1+_LoanRate[adjustservice]),term[adjustservice])-1)
     #Set loan rate, debt service and debt of agents who have paid off their loans to 0 (<=0) is used here since rounding errors can lead to slightly negative debt
    _LoanRate[_Debt<=0]=0
    _DebtService[_Debt<=0]=0
    _Debt[_Debt<=0]=0
    #Update liquidity based on shares of savings going into liquid assets by income percentile
    shares=_LiquidityShares[_IncomePercentiles.astype(int)]
    _Liquidity[_Liquidity>Liquidity_p]=Liquidity_p[_Liquidity>Liquidity_p]+shares[_Liquidity>Liquidity_p]*(_Liquidity[_Liquidity>Liquidity_p]-Liquidity_p[_Liquidity>Liquidity_p])
    
```

## Augment panel age

This short function augments the age of all solar panels in the model by one period. If the panel of an agent has reached its maximum age, the value of `_PV` is set to zero for that agent, as is the value of `_PanelAge` and `_PanelFIT` which gives the FIT received. The agent is then no longer a PV owner and will face the adoption decision again.

```{python}
def AugmentPanelAge(_PV,_PanelAge,_PanelFIT,_Params):
    _PanelAge[_PV==1]=_PanelAge[_PV==1]+1
    _PV[_PanelAge>_Params["PVMaxAge"].values[0]]=0
    _PanelFIT[_PanelAge>_Params["PVMaxAge"].values[0]]=0
    _PanelAge[_PanelAge>_Params["PVMaxAge"].values[0]]=0
    return[_PanelAge,_PV,_PanelFIT]
```

## Expectations formation

This function is used to generate a time-series of expected future electricity prices for each agents. These are needed below when agents decide whether or not to adopt PV.

Expectations formation of our bounded rational agents takes place using the well-established recursive least squares algorithm. Each agent has their own "internal" AR(1) model of the electricity price, the coefficients of which they update in every period using the latest observation of the actual electricity price in the model. Depending on the parameter setting, each individual agents may use a specific gain parameter to update their estimations, in which case the expected electricity prices differ across agents. In particular, agents with a high gain parameter will tend to update their estimated coefficients more strongly in reaction to new information, while agents with a low gain parameter will react less.

The first part of the function updates the internal AR(1) models of the agents, while the second projects the models to generate time-series of a length equal to the maximum lifespan of a solar panel. The function then returns the coefficients variance-covariance matrices of the updated AR(1) models and the time-series of expected prices.

```{python}
def FormExpectation(_ARPars,_ARMats,_Price,_Gain,_ExpectedPrice,_period):
    #Generate vector of independent variables --> constant=1 and current change in price
    independent=np.array([[1],[(_Price[(_period+1)]-_Price[_period])]])
    #Update variance-covariance matrices following recursive least squares algorithm
    mat1=np.dot(independent,independent.transpose())
    ARMatsNew=_ARMats+_Gain[:,None,None]*(mat1-_ARMats)
    #Test for singularity of updated matrices
    test=np.linalg.det(ARMatsNew)
    if(sum(test==0)>0):
        print('One or more matrices are singular!')
    #If updated matrix of an agent is singular, use old matrix
    _ARMats[np.where(test!=0)]=ARMatsNew[np.where(test!=0)]
    #Update coefficient estimates of agents' AR(1) models
    transposes=_ARPars.swapaxes(1,2)
    result1=np.dot(transposes,independent)
    dependent=_Price[(_period+2)]-_Price[(_period+1)]
    result1=dependent-result1
    result1=independent*result1
    result1=np.linalg.solve(_ARMats,result1)
    _ARPars=_ARPars+_Gain[:,None,None]*result1
    transposes1=_ARPars[:,0].transpose()
    transposes2=_ARPars[:,1].transpose()
    #Generate time-series of expected electricity price for each agent
    _ExpectedPrice[:,0]=(_Price[(_period+2)]+_ARPars[:,0]+_ARPars[:,1]*(_Price[(_period+2)]-_Price[(_period+1)])).transpose()
    _ExpectedPrice[:,1]=_ExpectedPrice[:,0]+transposes1+transposes2*(_ExpectedPrice[:,0]-_Price[(_period+2)])
    for t in range(2,len(_ExpectedPrice[0])):
        _ExpectedPrice[:,t]=_ExpectedPrice[:,(t-1)]+transposes1+transposes2*(_ExpectedPrice[:,(t-1)]-_ExpectedPrice[:,(t-2)])
    return[_ARMats,_ARPars,_ExpectedPrice]
```


## Adoption Decision

In this function, agents who do not yet own PV decide whether or not to purchase a panel.

The function first checks which agents would need a loan in order to adopt PV (namely those who do not have sufficient liquid assets to buy one outright). Based on the size of the loan needed, agents may be credit rationed if the resulting loan to value ratio exceeds the maximum permitted level (note that in the current implementation, `_Params["MaxLTV"]=1` such that this rationing mechanism is effectively switched off).

Next, the bank proposes a loan interest rate to every agent with positive borrowing needs based on the size of the required loan. From this, in turn, we calculate the size of the implied debt service payment. If the prospective debt service payment of an agent exceeds a certain fraction (`_Params["MaxDTI"]`) of their current income, the agent is credit rationed. Since the model only includes a single type of solar panel with a given installation cost, credit rationed agents cannot adopt (i.e. they cannot, for instance, buy a smaller panel with a smaller loan).

The function then calculates, for each agent, a sum of expected discounted revenue from owning PV over the lifetime of a panel, based on agents' expected future electricity prices, the value of the feed-in tariff for panels installed in the current year, agents' future electricity consumption (which, as outlined above, grows at a fixed rate every year), as well as a sum of discounted future loan costs based on the size of the needed loan and the interest rate proposed by the bank. 
As in the case of the function `IncomePowercost` outlined above, in calculating the expected cost-saving/revenue from owning PV, agents are divided into groups depending on whether their future electricity consumption is larger or smaller than the capacity of the solar panel and whether the current FIT is larger or smaller than the expected electricity price.
Based on the cumulative discounted expected revenue and loan cost and the one-off installation cost, an expected profit from owning PV is calculated.

This expected profit, in turn, feeds into the expected utility from adopting PV. In addition to profit, this utility also contains a component related to social influence (based on the difference between the share of other agents in a given agent's income decile who have already adopted PV and those who have not) and one related to environmental attitude.

Agents for whom expected utility is positive (and for whom PV is technically feasible and who are not credit-rationed) purchase a solar panel and their liquidity, debt, debt service payments and loan rates are updated accordingly.

```{python}
def AdoptionDecision(_PV,_Feasible,_Liquidity,_Rationed,_Debt,_Income,_Income_f,_Powercost_f,_Trend,_ExpectedPrice,_Discount,_Revenue,_LoanCost,_PVOwnershipDeciles,_IncomeDeciles,_LoanRate,_DebtService,_Influence,_Attitude,_Adopted,_CumulativeProfit,_FIT,_year,_PanelFIT,_Baserate,_Subsidy1,_Subsidy2,_CreditPolicy1,_CreditPolicy2,_Params):
    #Reset vector of dummies indicating whether agents are credit-rationed
    _Rationed[:]=0
    #Calculate loan needed to purchase PV
    loanneeded=(1-_Subsidy1)*_Params["PanelCost"].values[0]-_Liquidity
    #Agents who already have PV do not need a loan
    loanneeded[_PV==1]=0
    #Agents who can buy the panel outright do not need a loan
    loanneeded[(_PV==0) & (_Liquidity>=((1-_Subsidy1)*_Params["PanelCost"].values[0]))]=0
    #Agents for whom PV is not technically feasible do not need a loan
    loanneeded[_Feasible==0]=0
    #Check whether needed loan exceeds maximum loan to value ratio
    _Rationed[(loanneeded+_Debt)>((1-_Subsidy1)*_Params["PanelCost"].values[0]*(_Params["MaxLTV"].values[0]+_CreditPolicy1))]=1
    #Calculate interest rate proposed by the bank based on size of loan needed
    proposedrate=_Baserate[str(_year)].values[0]+_Params["InterestMarkup"].values[0]*(1+loanneeded/((1-_Subsidy1)*_Params["PanelCost"].values[0]*_Params["MaxLTV"].values[0]))
    #Calculate size of debt service payments
    payment=loanneeded*(proposedrate*(np.power(1+proposedrate,_Params["PVMaxAge"].values[0])))/((np.power(1+proposedrate,_Params["PVMaxAge"].values[0]))-1)
    #Check whether implied debt service to income ratio exceeds maximum permitted
    _Rationed[(payment/_Income)>(_Params["MaxDTI"].values[0]+_CreditPolicy2)]=1
    #Agents who do not need a loan are not rationed
    _Rationed[loanneeded==0]=0
    #Agents for whom PV is not technically feasible are not rationed
    _Rationed[_Feasible==0]=0
    #Agents who already own PV are not rationed
    _Rationed[_PV==1]=0
    #Initialise expected revenue from PV and cost of loan
    _Revenue[:]=0
    _LoanCost[:]=0
    #Initialise cost saving from PV
    costsaving=_Revenue.copy()
    #Initial remaining loan balance is equal to size of loan needed
    balanceremaining=loanneeded.copy()
    #Iterate over lifespan of a solar panel
    for t in range(_Params["PVMaxAge"].values[0]):
        costsaving[:]=0
        #Agents whose expected electricity consumption exceeds the capacity of the panel and for whom the current FIT is smaller than the expected electricity price
        group1=np.where((_ExpectedPrice[:,t]>=(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))>=_Params["PVCapacity"].values[0]))
        #Agents whose expected electricity consumption is smaller than the capacity of the panel and for whom the current FIT is smaller than the expected electricity price
        group2=np.where((_ExpectedPrice[:,t]>=(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))<_Params["PVCapacity"].values[0]))
        #Agents whose expected electricity consumption exceeds the capacity of the panel and for whom the current FIT is larger than the expected electricity price
        group3=np.where((_ExpectedPrice[:,t]<(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))>=_Params["PVCapacity"].values[0]))
        #Agents whose expected electricity consumption is smaller than the capacity of the panel and for whom the current FIT is larger than the expected electricity price
        group4=np.where((_ExpectedPrice[:,t]<(_FIT[str(_year)].values[0]+_Subsidy2)) & ((_Powercost_f*np.power((1+_Trend),t))<_Params["PVCapacity"].values[0]))
        #expected cost saving for group 1 is given by share of own consumption times capacity times expected price plus electricity fed into the grid times FIT
        costsaving[group1]=_ExpectedPrice[group1,t]*_Params["PVCapacity"].values[0]*_Params["PVCons"].values[0]+(1-_Params["PVCons"].values[0])*(_FIT[str(_year)].values[0]+_Subsidy2)*_Params["PVCapacity"].values[0]
        #expected cost saving for group 2 is given by minimum between own consumption share times capacity times expected price and expected electricity consumption times expected price, plus the remaining capacity of the panel times FIT
        costsaving[group2]=_ExpectedPrice[group2,t]*np.minimum(_Params["PVCons"].values[0]*_Params["PVCapacity"].values[0],_Powercost_f[group2]*np.power((1+_Trend[group2]),t))+(_FIT[str(_year)].values[0]+_Subsidy2)*(_Params["PVCapacity"].values[0]-np.minimum(_Params["PVCons"].values[0]*_Params["PVCapacity"].values[0],_Powercost_f[group2]*np.power((1+_Trend[group2]),t)))
        #expected cost saving for groups 3 and 4 is equal to FIT times capacity of the solar panel
        costsaving[group3]=(_FIT[str(_year)].values[0]+_Subsidy2)*_Params["PVCapacity"].values[0]
        costsaving[group4]=(_FIT[str(_year)].values[0]+_Subsidy2)*_Params["PVCapacity"].values[0]
        #Discounted value of expected cost saving is added to cumulative expected revenue
        _Revenue=_Revenue+costsaving/(np.power(1+_Discount,t))
        #Expected interest cost
        cost=proposedrate*balanceremaining
        #Remaining loan balance
        balanceremaining=balanceremaining-(payment-cost)
        #Discounted interest cost is added to cumulative expected cost of the loan
        _LoanCost=_LoanCost+cost/(np.power(1+_Discount,t))
    #Expected profit from PV ownership is given by cumulative discounted expected revenue minus installation cost (possibly reduced by subsidy) minus cumulative expected discounted cost of the loan
    profit=_Revenue-((1-_Subsidy1)*_Params["PanelCost"].values[0])-_LoanCost
    #For each agent, set variable deciles to the PV ownership rate in their own income decile
    deciles=_PVOwnershipDeciles[_IncomeDeciles.astype(int)]
    #Utility depends on profit, social influence component (deciles=share of other agents in decile who already have PV) and environmental attitude
    utility=profit+_Influence*(deciles-(1-deciles))+_Params["Beta"].values[0]*_Attitude
    #Assume that agents who had already adopted PV before but whose panel has reached maximum age will only consider expected profit when deciding whether to re-adopt
    utility[(_Adopted==1) & (_CumulativeProfit>0) & (_PV==0)]=profit
    #Re-set cumulative profit for agents who made a loss over the lifetime of their panel to 0
    _CumulativeProfit[(_Adopted==1) & (_CumulativeProfit<=0) & (_PV==0)]=0
    #Agents who are credit rationed will not adopt
    utility[_Rationed==1]=0
    #Agents for whom PV is not technically feasible will not adopt
    utility[_Feasible==0]=0
    #Agents who already own PV will not adopt
    utility[_PV==1]=0
    #Find agents who will adopt
    adopters=np.where(utility>0)
    #Find adopters who need a loan
    borrowers=np.where((utility>0) & (loanneeded>0))
    #Set PV dummy for adopters to 1
    _PV[adopters]=1
    #Set FIT for adopters (will be unchanged over the lifetime of the panel!)
    _PanelFIT[adopters]=_FIT[str(_year)].values[0]
    #Indicates whether agent adopted PV at any point during the run; set to 1 for adopters
    _Adopted[adopters]=1
    #Re-initialise cumulative profit for adopters
    _CumulativeProfit[adopters]=-((1-_Subsidy1)*_Params["PanelCost"].values[0])
    #Update liquidity for adopters, possibly including loan needed
    _Liquidity[adopters]=_Liquidity[adopters]-((1-_Subsidy1)*_Params["PanelCost"].values[0])+loanneeded[adopters]
    #Set loan rate for borrowers
    _LoanRate[borrowers]=proposedrate[borrowers]*loanneeded[borrowers]/(loanneeded[borrowers]+_Debt[borrowers])+_LoanRate[borrowers]*_Debt[borrowers]/(loanneeded[borrowers]+_Debt[borrowers])
    #Set debt level and debt service payments for borrowers
    _Debt[borrowers]=_Debt[borrowers]+loanneeded[borrowers]
    _DebtService[borrowers]=_Debt[borrowers]*(_LoanRate[borrowers]*(np.power(1+_LoanRate[borrowers],_Params["PVMaxAge"].values[0])))/((np.power(1+_LoanRate[borrowers],_Params["PVMaxAge"].values[0]))-1)
    return[_PV,_Rationed,_Liquidity,_LoanRate,_Debt,_DebtService,_Adopted,_CumulativeProfit,_PanelFIT]
```

## PV Deciles

This function calculates the share of agents who own PV in each decile. It is called at the end of a simulation period and, because an initial value is needed for the adoption decision in the first simulation period, once after function `IncomeGroups` during the first simulation period. It determines the overall number of agents in each income decile as well as the number of agents owning PV in each decile in order to calculate a PV ownership rate for each decile.

```{python}
def PVDeciles(_Income_p,_PV,_Positions_d,_Deciles,_PVOwnershipDeciles,_DecileMembers):
    #Sort vector of income net of electricity cost in ascending order
    income_psorted=np.sort(_Income_p)
    #Based on sorted income and number of agents in each decile, set cut-off points
    _Deciles[0:9]=income_psorted[_Positions_d]
    _Deciles[9]=income_psorted[((income_psorted.size)-1)]
    #Iterate over deciles
    for i in range(10):
        #Determine which agents belong to decile i
        if i==0:
            members=np.where(_Income_p<=_Deciles[i])
        else:
            members=np.where((_Income_p<=_Deciles[i]) & (_Income_p>_Deciles[(i-1)]))
        #Set the number of agents in decile i
        _DecileMembers[i]=members[0].size
        #Set the number of agents owning PV in decile i
        _PVOwnershipDeciles[i]=_PV[members[0]].sum()
    #Calculate ownership rate by decile
    _PVOwnershipDeciles=_PVOwnershipDeciles/_DecileMembers
    return[_PVOwnershipDeciles]
```



## Calculate statistics

This function calculates a range of statistics, time-series of which will be returned by the main function at the end of a simulation.

```{python}
def CalculateStatistics(_PV,_Income,_Debt,_Liquidity,_ExpectedPrice,_Feasible,_Rationed):
    #Average income
    averageincome=np.sum(_Income)/_Income.size
    #Average Liquidity
    averageliquidity=np.sum(_Liquidity)/_Liquidity.size
    #Average expected price in t+1
    averageexpectedprice=np.sum(_ExpectedPrice)/_ExpectedPrice.size
    #Average debt, only taking into account agents with positive debt
    if np.sum(_Debt>0)>0:
        averagedebt=np.sum(_Debt[_Debt>0])/np.sum(_Debt>0)
    else:
        averagedebt=0
    #Adoption rate taking into account all agents
    adoptionrate1=np.sum(_PV)/_PV.size
    #Adoption rate taking into account only agents for whom PV is technically feasible
    if np.sum(_Feasible)>0:
        adoptionrate2=np.sum(_PV)/np.sum(_Feasible)
    else:
        adoptionrate2=0
    #Share of agents who are credit-rationed
    if np.sum((_PV==0) & (_Feasible==1))>0:
        rationing=np.sum(_Rationed)/np.sum((_PV==0) & (_Feasible==1))
    else:
        rationing=0
    return(averageincome,averageliquidity,averageexpectedprice,averagedebt,adoptionrate1,adoptionrate2,rationing)
```

## Main model function

This is the function which must be called to execute the model. It takes several inputs, namely:

::: incremental
-   `inputfile` - a csv file containing a a list of all model households and their initial characteristics
-   `propensitiesfile` - a csv file containing propensities to consume out of income by income percentile
-   `liquiditysharesfile` - a csv file containing the shares of saving going into liquid assets by income percentile
-   `fitfile` - a csv containing the value of the feed-in tariff for solar panels installed in each simulation year
-   `costfile` - a csv containing an annual time-series of installation cost of a solar panel
-   `ratefile` - a csv containing an annual time-series of central bank base interest rates
-   `pricefile` - a csv containing an annual time-series of electricity prices
-   `paramfile` - a csv file containing the names and values of all model parameters
-   `seed` - a seed for the pseudo-random number generator
-   `start` - the start year of the model simulation
-   `end` - the end year of the model simulation
:::

The function begins by setting the seed for the pseudo-random number generator, and then loads all necessary external input files. It then initialises the model by generating vectors/arrays of all model variables and setting initial values where necessary.

Subsequently, there is a single call to `GenerateElectricityPrice` in order to generate a time-series of electricity prices for the current model run. Subsequently, one of the electricity price time-series is used to train the agents' expectations formation algorithm. After this, the main simulation loop is entered. In each simulation period, the model calls the functions described above one after the other, updating the relevant model variables based on the outputs of each function.

At the end of the simulation run, the time-series of aggregate statistics to be returned are stacked into a single array and converted to a dataframe, which is then saved in csv format, with the seed number attached to the file name. Similarly, the time-series of PV adoption rates by income decile are saved in csv format, with the seed number attached to the file name.

```{python}
def PVModel(inputfile="inputs.csv",propensitiesfile="consumptionpropensities.csv",liquiditysharesfile="liquidityshares.csv",fitfile="FIT.csv",costfile="pvcost.csv",ratefile="baserate.csv",pricefile="electricityprice.csv",paramfile="parameters.csv",seed=1,runname="test",start=2018,end=2040):
    #Set seed
    np.random.seed(seed)
    
    #Load external input files
    Inputs=pd.read_csv(inputfile)
    Params=pd.read_csv(paramfile)
    Propensities=np.ndarray.flatten(pd.read_csv(propensitiesfile,header=None).to_numpy())
    LiquidityShares=np.ndarray.flatten(pd.read_csv(liquiditysharesfile,header=None).to_numpy())
    FIT=pd.read_csv(fitfile)
    PVCost=pd.read_csv(costfile)
    Baserate=pd.read_csv(ratefile)
    PriceEmp=pd.read_csv(pricefile)

    #Initialise deterministic mean values for income
    Income_f=np.ndarray.flatten(Inputs[["income"]].to_numpy())
    #Create matrix for actual income
    Income=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Create matrix for income net of power cost
    Income_p=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Set values for standard deviation of income
    Income_sd=np.ndarray.flatten(Inputs[["incomesd"]].to_numpy())
    #Initialise deterministic values of electricity consumption
    Powercost_f=np.ndarray.flatten(Inputs[["powercons"]].to_numpy())
    #Create matrix for actual power cost (including price)
    Powercost=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Create vector for current consumption
    Consumption=np.zeros(len(Inputs.index))
    #Create matrix for liquidity and set initial values
    Liquidity=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    Liquidity[:,0]=np.ndarray.flatten(Inputs[["liquidity"]].to_numpy())
    #Create vectors for debt, debt service payments and loan rates
    Debt=np.zeros(len(Inputs.index))
    DebtService=np.zeros(len(Inputs.index))
    LoanRate=np.zeros(len(Inputs.index))

    #Set trend rates at which electricity consumption and mean values of income will grow
    Trend=np.ndarray.flatten(Inputs[["trend"]].to_numpy())
    #Set housing dummy (1=agent lives in house, 0=agent lives in flat)
    House=np.ndarray.flatten(Inputs[["house"]].to_numpy())
    #Create matrix for current PV ownership dummies and set initial values (1=currently owns PV)
    PV=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    PV[:,0]=np.ndarray.flatten(Inputs[["pv"]].to_numpy())
    #Initialise age of solar panels
    PanelAge=np.ndarray.flatten(Inputs[["panelage"]].to_numpy())
    #Set environmental attitudes
    Attitude=np.ndarray.flatten(Inputs[["attitude"]].to_numpy())
    #Set strength of social influence for each agent
    Influence=np.random.uniform(0,1,len(Inputs.index))*(Params["MaxInfluence"].values[0]-Params["MinInfluence"].values[0])+Params["MinInfluence"].values[0]
    #Set discount rate for each agent
    Discount=np.ndarray.flatten(Inputs[["discount"]].to_numpy())
    #Create vector of dummies indicating whether PV is technically feasible
    Feasible=np.zeros(len(Inputs.index))
    #If agent already owns PV, it is feasible
    Feasible[PV[:,0]==1]=1
    #If agent lives in house, it is feasible
    Feasible[House==1]=1
    #If agent lives in flat, PV is feasible with a certain probability
    Feasible[(House==0) & (PV[:,0]==0)]=np.random.uniform(0,1,sum((House==0) & (PV[:,0]==0)))
    Feasible[Feasible>=(1-Params["FeasibilityProb"].values[0])]=1
    Feasible[Feasible<(1-Params["FeasibilityProb"].values[0])]=0
    #Create vector to hold feed-in tariffs earned by each agent
    PanelFIT=np.zeros(len(Inputs.index))
    #Find the oldest existing panel
    maxage=max(PanelAge)
    for a in range(maxage+1):
        #Set the adoption year
        yearadopted=start-(a+1)
        #If the adoption year is within the range of the time-series of FITs, set the FIT of all agents who adopted in that year to the appropriate value
        if sum(str(yearadopted)==FIT.columns)==1:
            PanelFIT[(PV[:,0]==1) & (PanelAge==a)]=FIT[str(yearadopted)].values[0]
        #Otherwise, set the FIT to the earliest available value
        else:
            PanelFIT[(PV[:,0]==1) & (PanelAge==a)]=FIT.iloc[0,0]

    #Set the cutoff points for income percentiles
    Positions_p=np.zeros(99)
    Positions_p[:]=np.array(range(1,100,1))*(len(Inputs.index)+1)/100-1
    Positions_p=np.round(Positions_p)
    Positions_p=Positions_p.astype(int)
    #Create vector to hold income value associated with each percentile
    Percentiles=np.zeros(100)
    #Set the cutoff points for income deciles
    Positions_d=np.zeros(9)
    Positions_d[:]=np.array(range(1,10,1))*(len(Inputs.index)+1)/10-1
    Positions_d=np.round(Positions_d)
    Positions_d=Positions_d.astype(int)
    #Create vector to hold income value associated with each decile
    Deciles=np.zeros(10)
    #Create vector to hold number of agents in each decile
    DecileMembers=np.zeros(10)
    #Create vector to hold PV ownership rate in each decile
    PVOwnershipDeciles=np.zeros(10)
    #Create vectors to hold the income deciles and percentiles of each agent
    IncomeDeciles=np.zeros(len(Inputs.index))
    IncomePercentiles=np.zeros(len(Inputs.index))

    #Set the gain parameter used by each agent in the recursive least squares learning algorithm
    Gain=np.random.uniform(0,1,len(Inputs.index))*(Params["MaxGain"].values[0]-Params["MinGain"].values[0])+Params["MinGain"].values[0]
    #Initialise agents' estimates of parameters and variance-covariance matrices
    ARPars=np.array([[Params["ElectricityPriceTrend"].values[0]],[Params["ElectricityPriceAR"].values[0]]])
    ARPars=[ARPars]*len(Inputs.index)
    ARPars=np.array(ARPars)
    ARMats=np.array([[Params["ElectricityPriceMat11"].values[0],Params["ElectricityPriceMat12"].values[0]],[Params["ElectricityPriceMat21"].values[0],Params["ElectricityPriceMat22"].values[0]]])
    ARMats=[ARMats]*len(Inputs.index)
    ARMats=np.array(ARMats)
    #Create a matrix to hold agents' expected electricity prices
    ExpectedPrice=np.zeros(shape=(len(Inputs.index),Params["PVMaxAge"].values[0]))

    #Initialise policy variables
    #Subsidy on purchase price of panel
    Subsidy1=0
    #Additional subsidy on FIT
    Subsidy2=0
    #Change in maximum loan to value ratio
    CreditPolicy1=0
    #Change in maximum debt service to income ratio
    CreditPolicy2=0

    #Create vector to hold expected discounted cumulative revenue from owning PV
    Revenue=np.zeros(len(Inputs.index))
    #Create vector to hold expected discounted cumulative loan cost to purchase PV
    LoanCost=np.zeros(len(Inputs.index))
    #Create vector to hold dummies indicating whether agents are credit-rationed
    Rationed=np.zeros(len(Inputs.index))
    #Create vector to hold actual cumulative profit derived from owning PV
    CumulativeProfit=np.zeros(len(Inputs.index))
    #Create vector of dummies indicating whether agent has at any point owned PV
    Adopted=np.zeros(len(Inputs.index))
    #Set initial values for agents already owning PV at the start of the simulation
    Adopted[PV[:,0]==1]=1
    #To initialise the cumulative profit on pre-existing solar panels, we divide agents owning PV into 4 groups
    #Group 1 contains agents who own PV, whose electricity consumption is greater than the capacity of the panel, and whose FIT is lower than the starting value of the electricity price
    group1=np.where((PV[:,0]==1) & (Powercost_f>=Params["PVCapacity"].values[0]) & ((PanelFIT+Subsidy2)<PriceEmp[str(start-1)].values[0]))
    #Group 2 contains agents who own PV, whose electricity consumption is greater than the capacity of the panel, and whose FIT is higher than the starting value of the electricity price
    group2=np.where((PV[:,0]==1) & (Powercost_f>=Params["PVCapacity"].values[0]) & ((PanelFIT+Subsidy2)>=PriceEmp[str(start-1)].values[0]))
    #Group 3 contains agents who own PV, whose electricity consumption is smaller than the capacity of the panel, and whose FIT is lower than the starting value of the electricity price
    group3=np.where((PV[:,0]==1) & (Powercost_f<Params["PVCapacity"].values[0]) & ((PanelFIT+Subsidy2)<PriceEmp[str(start-1)].values[0]))
    #Group 4 contains agents who own PV, whose electricity consumption is lower than the capacity of the panel, and whose FIT is higher than the starting value of the electricity price
    group4=np.where((PV[:,0]==1) & (Powercost_f<Params["PVCapacity"].values[0]) & ((PanelFIT+Subsidy2)>=PriceEmp[str(start-1)].values[0]))
    #Cumulative profit of agents in group 1 is initialised as share of own consumption times capacity of the panel times initial electricity price plus remaining capacity times FIT
    CumulativeProfit[group1]=Params["PVCons"].values[0]*Params["PVCapacity"].values[0]*PriceEmp[str(start-1)].values[0]+(1-Params["PVCons"].values[0])*Params["PVCapacity"].values[0]*(PanelFIT[group1]+Subsidy2)
    #Cumulative profit of agents in group 2 is initialised as capacity of panel times FIT
    CumulativeProfit[group2]=Params["PVCapacity"].values[0]*(PanelFIT[group2]+Subsidy2)
    #Cumulative profit of agents in group 3 is initialised as minimum between share of own consumption times capacity of the panel and electricity consumption times initial electricity price plus remaining capacity times FIT
    CumulativeProfit[group3]=np.minimum(Params["PVCons"].values[0]*Params["PVCapacity"].values[0],Powercost_f[group3])*PriceEmp[str(start-1)].values[0]+(PanelFIT[group3]+Subsidy2)*(Params["PVCapacity"].values[0]-np.minimum(Params["PVCons"].values[0]*Params["PVCapacity"].values[0],Powercost_f[group3]))
    #Cumulative profit of agents in group 4 is initialised as capacity of panel times FIT
    CumulativeProfit[group4]=Params["PVCapacity"].values[0]*(PanelFIT[group4]+Subsidy2)
    #For simplicity, assume that agents earned this profit in all previous periods
    CumulativeProfit=CumulativeProfit*PanelAge
    #Subtract from cumulative profit the cost of PV from the year in which it was installed
    for a in range(maxage+1):
        yearadopted=start-(a+1)
        if sum(str(yearadopted)==PVCost.columns)==1:
            CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]=CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]-(1-Subsidy1)*PVCost[str(yearadopted)].values[0]
        #If a panel is older than the earliest available value for panel cost, use the earliest value
        else:
            CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]=CumulativeProfit[(PV[:,0]==1) & (PanelAge==a)]-(1-Subsidy1)*PVCost.iloc[0,0]


    #Initialise aggregate statistics
    AverageIncome=np.zeros((end-start+1))
    AverageLiquidity=np.zeros((end-start+1))
    AverageExpectedPrice=np.zeros((end-start+1))
    AverageDebt=np.zeros((end-start+1))
    AdoptionRate1=np.zeros((end-start+1))
    AdoptionRate2=np.zeros((end-start+1))
    AdoptionRateDeciles=np.zeros(((end-start+1),10))
    ChangeAdoptionRate1=np.zeros((end-start+1))
    ChangeAdoptionRate2=np.zeros((end-start+1))
    RationedShare=np.zeros((end-start+1))

    #Generate two electricity price time-series
    PriceReturn=GenerateElectricityPrice(_PriceEmp=PriceEmp.copy(),_Params=Params.copy(),_length=(end-start+3),_start=start)
    #Price series to be used in the simulation
    Price=PriceReturn[0]
    #Price series used to train agents' expectations formation
    PriceTrain=PriceReturn[1]
    #Use PriceTrain to train agents' expectations formation using a number of time-steps equal to the length of the actual simulation
    for period in range((end-start+1)):
        ExpectationReturn=FormExpectation(_ARPars=ARPars.copy(),_ARMats=ARMats.copy(),_Price=PriceTrain.copy(),_Gain=Gain.copy(),_ExpectedPrice=ExpectedPrice.copy(),_period=period)
        ARMats=ExpectationReturn[0]
        ARPars=ExpectationReturn[1]
        ExpectedPrice=ExpectationReturn[2]
    
    #Enter main model loop
    #Set the current year to the start year supplied to the function
    year=start
    for period in range((end-start+1)):
        #Set the purchase and installation cost of a solar panel equal to the value for the current year
        Params["PanelCost"]=PVCost[str(year)].values[0]
        #Set starting value for liquid wealth and PV equal to closing value from last period
        if period>0:
            Liquidity[:,period]=Liquidity[:,(period-1)]
            PV[:,period]=PV[:,(period-1)]
        #Set policy variables
        PolicyReturn=SetPolicy(_Subsidy1=Subsidy1,_Subsidy2=Subsidy2,_CreditPolicy1=CreditPolicy1,_CreditPolicy2=CreditPolicy2,_year=year,_Params=Params.copy())
        Subsidy1=PolicyReturn[0]
        Subsidy2=PolicyReturn[1]
        CreditPolicy1=PolicyReturn[2]
        CreditPolicy2=PolicyReturn[3]
        #Calculate income and electricity cost
        IncomePowercostReturn=IncomePowercost(_Income_f=Income_f.copy(),_Trend=Trend.copy(),_Powercost_f=Powercost_f.copy(),_Income_sd=Income_sd.copy(),_CumulativeProfit=CumulativeProfit.copy(),_PV=PV[:,period].copy(),_Price=Price[(period+2)].copy(),_PanelFIT=PanelFIT.copy(),_Subsidy2=Subsidy2,_Params=Params.copy())
        Income[:,period]=IncomePowercostReturn[0]
        Powercost[:,period]=IncomePowercostReturn[1]
        Income_p[:,period]=IncomePowercostReturn[2]
        CumulativeProfit[:]=IncomePowercostReturn[3]
        Income_f[:]=IncomePowercostReturn[4]
        Powercost_f[:]=IncomePowercostReturn[5]
        #Calculate income distribution statistics
        IncomeGroupReturn=IncomeGroups(_Income_p=Income_p[:,period].copy(),_Positions_p=Positions_p.copy(),_Percentiles=Percentiles.copy(),_Positions_d=Positions_d.copy(),_Deciles=Deciles.copy(),_IncomePercentiles=IncomePercentiles.copy(),_IncomeDeciles=IncomeDeciles.copy())
        IncomePercentiles[:]=IncomeGroupReturn[0]
        IncomeDeciles[:]=IncomeGroupReturn[1]
        #In first simulation period, initialise PV ownership by decile
        if period==0:
            PVDecileReturn=PVDeciles(_Income_p=Income_p[:,period].copy(),_PV=PV[:,period].copy(),_Positions_d=Positions_d.copy(),_PVOwnershipDeciles=PVOwnershipDeciles.copy(),_Deciles=Deciles.copy(),_DecileMembers=DecileMembers.copy())
            PVOwnershipDeciles[:]=PVDecileReturn[0]
        #Calculate consumption and saving
        ConsumptionSavingReturn=ConsumptionSaving(_Income_p=Income_p[:,period].copy(),_Propensities=Propensities.copy(),_IncomePercentiles=IncomePercentiles.copy(),_Consumption=Consumption.copy(),_Income=Income[:,period].copy(),_Powercost=Powercost[:,period].copy(),_Liquidity=Liquidity[:,period].copy(),_Debt=Debt.copy(),_DebtService=DebtService.copy(),_LoanRate=LoanRate.copy(),_PanelAge=PanelAge.copy(),_CumulativeProfit=CumulativeProfit.copy(),_LiquidityShares=LiquidityShares.copy(),_Params=Params.copy(),_period=period)
        Liquidity[:,period]=ConsumptionSavingReturn[0]
        Debt[:]=ConsumptionSavingReturn[1]
        DebtService[:]=ConsumptionSavingReturn[2]
        LoanRate[:]=ConsumptionSavingReturn[3]
        Consumption[:]=ConsumptionSavingReturn[4]
        CumulativeProfit[:]=ConsumptionSavingReturn[5]
        #Increment age of existing panels
        PanelAgeReturn=AugmentPanelAge(_PV=PV[:,period].copy(),_PanelAge=PanelAge.copy(),_PanelFIT=PanelFIT.copy(),_Params=Params.copy())
        PanelAge=PanelAgeReturn[0]
        PV[:,period]=PanelAgeReturn[1]
        PanelFIT=PanelAgeReturn[2]
        #Form expectations
        ExpectationReturn=FormExpectation(_ARPars=ARPars.copy(),_ARMats=ARMats.copy(),_Price=Price.copy(),_Gain=Gain.copy(),_ExpectedPrice=ExpectedPrice.copy(),_period=period)
        ARMats=ExpectationReturn[0]
        ARPars=ExpectationReturn[1]
        ExpectedPrice=ExpectationReturn[2]
        #Adoption decision
        AdoptionReturn=AdoptionDecision(_PV=PV[:,period].copy(),_Feasible=Feasible.copy(),_Liquidity=Liquidity[:,period].copy(),_Rationed=Rationed.copy(),_Debt=Debt.copy(),_Income=Income[:,period].copy(),_Income_f=Income_f.copy(),_Powercost_f=Powercost_f.copy(),_Trend=Trend.copy(),_ExpectedPrice=ExpectedPrice.copy(),_Discount=Discount.copy(),_Revenue=Revenue.copy(),_LoanCost=LoanCost.copy(),_PVOwnershipDeciles=PVOwnershipDeciles.copy(),_IncomeDeciles=IncomeDeciles.copy(),_LoanRate=LoanRate.copy(),_DebtService=DebtService.copy(),_Influence=Influence.copy(),_Attitude=Attitude.copy(),_Adopted=Adopted.copy(),_CumulativeProfit=CumulativeProfit.copy(),_FIT=FIT.copy(),_year=year,_PanelFIT=PanelFIT.copy(),_Baserate=Baserate.copy(),_Subsidy1=Subsidy1,_Subsidy2=Subsidy2,_CreditPolicy1=CreditPolicy1,_CreditPolicy2=CreditPolicy2,_Params=Params.copy())
        PV[:,period]=AdoptionReturn[0]
        Rationed[:]=AdoptionReturn[1]
        Liquidity[:,period]=AdoptionReturn[2]
        LoanRate[:]=AdoptionReturn[3]
        Debt[:]=AdoptionReturn[4]
        DebtService[:]=AdoptionReturn[5]
        Adopted[:]=AdoptionReturn[6]
        CumulativeProfit[:]=AdoptionReturn[7]
        PanelFIT[:]=AdoptionReturn[8]
        #Calculate aggregate statistics
        StatisticsReturn=CalculateStatistics(_PV=PV[:,period].copy(),_Income=Income[:,period].copy(),_Debt=Debt.copy(),_Liquidity=Liquidity[:,period].copy(),_ExpectedPrice=ExpectedPrice[:,0].copy(),_Feasible=Feasible.copy(),_Rationed=Rationed.copy())
        AverageIncome[period]=StatisticsReturn[0]
        AverageLiquidity[period]=StatisticsReturn[1]
        AverageExpectedPrice[period]=StatisticsReturn[2]
        AverageDebt[period]=StatisticsReturn[3]
        AdoptionRate1[period]=StatisticsReturn[4]
        AdoptionRate2[period]=StatisticsReturn[5]
        RationedShare[period]=StatisticsReturn[6]
        #Calculate change in adoption rates
        if period>0:
            ChangeAdoptionRate1[period]=AdoptionRate1[period]-AdoptionRate1[(period-1)]
            ChangeAdoptionRate2[period]=AdoptionRate2[period]-AdoptionRate2[(period-1)]
        #Calculate PV ownership rate by decile    
        PVDecileReturn=PVDeciles(_Income_p=Income_p[:,period].copy(),_PV=PV[:,period].copy(),_Positions_d=Positions_d.copy(),_PVOwnershipDeciles=PVOwnershipDeciles.copy(),_Deciles=Deciles.copy(),_DecileMembers=DecileMembers.copy())
        PVOwnershipDeciles[:]=PVDecileReturn[0]
        AdoptionRateDeciles[period]=PVOwnershipDeciles
        #Increment year
        year=year+1

    #Save aggregate statistics and ownership rates by decile
    Stats=np.column_stack((AverageIncome,AverageLiquidity,AverageExpectedPrice,AverageDebt,AdoptionRate1,AdoptionRate2,ChangeAdoptionRate1,ChangeAdoptionRate2,RationedShare,Price[2:len(Price)]))
    Stats=pd.DataFrame(data=Stats,columns=["AverageIncome","AverageLiquidity","AverageExpectedPrice","AverageDebt","AdoptionRate1","AdoptionRate2","ChangeAdoptionRate1","ChangeAdoptionRate2","RationedShare","Price"])
    Stats_m=pd.DataFrame(data=AdoptionRateDeciles,columns=["1","2","3","4","5","6","7","8","9","10"])
    filename='outputSolar/out_'
    filename+=runname
    filename+="_"
    filename+=str(seed)
    filename+='.csv'
    filename2='outputSolar/out_deciles_'
    filename2+=runname
    filename2+="_"
    filename2+=str(seed)
    filename2+='.csv'
    Stats.to_csv(filename)
    Stats_m.to_csv(filename2)
```

## 
