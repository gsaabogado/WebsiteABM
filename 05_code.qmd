---
title: "Model Code"
format: 
  html: 
    toc: true
    warning: false
    code-fold: false
editor: visual
jupyter: python3
---

The model is written in Python. Below we provide a step-by-step documentation of all model functions. In total the model consists of 9 separate functions which are called at each time step plus one main function containing the initialisation and the main simulation loop, which we describe last.

## Generate Electricity Price

This function is called once at the beginning of a simulation run in order to generate a time-series of the electricity price which agents have to pay at each time-step of the simulation (note that this is different from the expected future electricity price, described below). As explained in the model description section, this electricity price is generated by simulating an AR(1) model estimated on electricity price data for Germany.

The function takes two inputs, namely `Params`, which is a pandas dataframe containing the names and values of the model parameters and `length`, an integer denoting the length of the simulation.

The function then creates a numpy vector of zeros of size `length`. The first element of the vector is set to the initial electricity price taken from `Params`, while the second is set to the initial price plus the trend component, i.e. the intercept from the AR(1) model. All subsequent elements are then generated by iterating the AR(1) model forward, including a normally distributed random shock the standard deviation of which is taken from the standard deviation of the residuals from the estimation of the AR(1) model. Finally, the function returns the time-series of the electricity price.

```{python}
def GenerateElectricityPrice(Params,length):
    electricityprice=np.zeros(length)
    electricityprice[0]=Params["ElectricityPriceInit"].values[0]
    electricityprice[1]=electricityprice[0]+Params["ElectricityPriceTrend"].values[0]
    for t in range(2,length):
        shock=Params["ElectricityPriceSD"].values[0]*np.sqrt(-2*np.log(np.random.uniform(0,1,1)))*np.cos(2*np.pi*np.random.uniform(0,1,1))
        electricityprice[t]=electricityprice[t-1]+Params["ElectricityPriceTrend"].values[0]+Params["ElectricityPriceAR"].values[0]*(electricityprice[t-1]-electricityprice[t-2])+shock
    return electricityprice
```

## Set Policy

Depending on the values of various dummies in the `Params` dataframe and the current simulation period, this function determines whether a policy experiment should be activated in the current period. At present, the model includes four possible policies, namely a subsidy on the cost of a solar panel (`Subsidy1`), a subsidy on the price at which electricity generated by PV can be sold to the grid (`Subsidy2`), a policy increasing the maximum permitted loan to value ratio for bank loans to acquire PV (`CreditPolicy1`, currently not used since in the baseline the maximum LTV is already set to 1), and a policy increasing the maximum allowed debt service to income ratio resulting from a loan made to acquire PV (`CreditPolicy2`). For instance, if the dummy `Subsidy1` is set to 1 and if the current simulation period (expressed as a year) is equal to or larger than `SubsidyStart`, a subsidy on the installation cost of PV will be activated. The function checks the conditions for the respective policy variables in each period, changes them if necessary, and then returns them.

```{python}
def SetPolicy(Subsidy1,Subsidy2,CreditPolicy1,CreditPolicy2,year,Params):
    if Params["Subsidy1"].values[0]==1 & year>=Params["SubsidyStart"].values[0]:
        Subsidy1=Params["s1"].values[0]
    if Params["Subsidy2"].values[0]==1 & year>=Params["SubsidyStart"].values[0]:
        Subsidy2=Params["s2"].values[0]
    if Params["CreditPolicy1"].values[0]==1 & year>=Params["CreditPolicyStart"].values[0]:
        CreditPolicy1=Params["cp1"].values[0]
    if Params["CreditPolicy2"].values[0]==1 & year>=Params["CreditPolicyStart"].values[0]:
        CreditPolicy2=Params["cp2"].values[0]
    return[Subsidy1,Subsidy2,CreditPolicy1,CreditPolicy2]
```

## Income and Power cost

This function generates the random incomes and electricity costs for each agent in every period. `Income_f` and `Powercost_f` are vectors of length *N*, where *N* is the number of agents in the model.
The deterministic mean value of income and power cost for each agent is assumed to grow at rate `Trend` (which may be heterogeneous across agents) at each time step. 
We then draw the actual income and power cost for each agent in the current period using uniform draws which are then transformed into draws from a normal distribution with means `Income_f` and `Powercost_f` respectively and standard deviations `Income_sd` and `Powercost_sd` respectively. Both income and power cost are constrained to be positive.
If an agent owns PV, the amount it has to pay for electricity is reduced by the capacity of the panel times the current electricity price.
Finally, we also calculate `income_p`, a measure of income net of electricity cost for each agent.

```{python}
def IncomePowercost(Income_f,Trend,Powercost_f,Income_sd,Powercost_sd,PV,Price,Subsidy2,Params):
    Income_f=Income_f*(1+Trend)
    Powercost_f=Powercost_f*(1+Trend)
    randincome=np.random.uniform(0,1,Income_f.size)
    randincome2=np.random.uniform(0,1,Income_f.size)
    randpowercost=np.random.uniform(0,1,Powercost_f.size)
    randpowercost2=np.random.uniform(0,1,Powercost_f.size)
    randincome=np.sqrt(-2*np.log(randincome))*np.cos(2*np.pi*randincome2)
    randpowercost=np.sqrt(-2*np.log(randpowercost))*np.cos(2*np.pi*randpowercost2)
    randincome=Income_sd*randincome*Income_f+Income_f
    randincome=np.maximum(1e-10,randincome)
    randpowercost=Powercost_sd*randpowercost*Powercost_f+Powercost_f
    randpowercost=np.maximum(1e-10,randpowercost)
    randpowercost=(randpowercost-PV*(1+Subsidy2)*Params["PVCapacity"].values[0])*Price
    income_p=randincome-randpowercost
    return[randincome,randpowercost,income_p]
```


##
