---
title: "Model Code"
author: "Severin Reissl and Luis Sarmiento"
format: 
  html: 
    toc: true
    warning: false
    code-fold: false
editor: visual
jupyter: python3
---

The model is written in Python. Below we provide a step-by-step documentation of all model functions. In total the model consists of 9 separate functions which are in turn called by one main model function containing the initialisation and the main simulation loop, which we describe last.

## Generate Electricity Price

This function is called once at the beginning of a simulation run in order to generate a time-series of the electricity price which agents have to pay at each time-step of the simulation (note that this is different from the expected future electricity price, described below). As explained in the model description section, this electricity price is generated by simulating an AR(1) model estimated on electricity price data for Germany.

The function takes two inputs, namely `Params`, which is a pandas dataframe containing the names and values of the model parameters and `length`, an integer denoting the length of the time-series to be created (given by simulation length+2 since we need two lagged values at the beginning for the expectations formation process discussed below).

The function then creates a numpy vector of zeros of size `length`. The first element of the vector is set to the initial electricity price taken from `Params`, while the second is set to the initial price plus the trend component, i.e. the intercept from the AR(1) model. All subsequent elements are then generated by iterating the AR(1) model forward, including a normally distributed random shock the standard deviation of which is taken from the standard deviation of the residuals from the estimation of the AR(1) model. Finally, the function returns the time-series of the electricity price.

```{python}
def GenerateElectricityPrice(Params,length):
    #Create vector of zeros
    electricityprice=np.zeros(length)
    #First element equal to initial price
    electricityprice[0]=Params["ElectricityPriceInit"].values[0]
    #Second element equal to initial price plus intercept from AR(1) model
    electricityprice[1]=electricityprice[0]+Params["ElectricityPriceTrend"].values[0]
    #Iterate over rest of vector
    for t in range(2,length):
        #Generate normally distributed shock based on standard deviation of regression residuals
        shock=Params["ElectricityPriceSD"].values[0]*np.sqrt(-2*np.log(np.random.uniform(0,1,1)))*np.cos(2*np.pi*np.random.uniform(0,1,1))
        #Price in t calculated by iterating AR(1) model
        electricityprice[t]=electricityprice[t-1]+Params["ElectricityPriceTrend"].values[0]+Params["ElectricityPriceAR"].values[0]*(electricityprice[t-1]-electricityprice[t-2])+shock
    #Return the vector of prices
    return electricityprice
```

## Set Policy

Depending on the values of various dummies in the `Params` dataframe and the current simulation period, this function determines whether a policy experiment should be activated in the current period.

At present, the model includes four possible policies, namely a subsidy on the cost of a solar panel (`Subsidy1`), a subsidy on the price at which electricity generated by PV can be sold to the grid (`Subsidy2`), a policy increasing the maximum permitted loan to value ratio for bank loans to acquire PV (`CreditPolicy1`, currently not used since in the baseline the maximum LTV is already set to 1), and a policy increasing the maximum allowed debt service to income ratio resulting from a loan made to acquire PV (`CreditPolicy2`). For instance, if the dummy `Subsidy1` is set to 1 and if the current simulation period (expressed as a year) is equal to or larger than `SubsidyStart`, a subsidy on the installation cost of PV will be activated. The function checks the conditions for the respective policy variables in each period, changes them if necessary, and then returns them.

```{python}
def SetPolicy(Subsidy1,Subsidy2,CreditPolicy1,CreditPolicy2,year,Params):
    if Params["Subsidy1"].values[0]==1 & year>=Params["SubsidyStart"].values[0]:
        Subsidy1=Params["s1"].values[0]
    if Params["Subsidy2"].values[0]==1 & year>=Params["SubsidyStart"].values[0]:
        Subsidy2=Params["s2"].values[0]
    if Params["CreditPolicy1"].values[0]==1 & year>=Params["CreditPolicyStart"].values[0]:
        CreditPolicy1=Params["cp1"].values[0]
    if Params["CreditPolicy2"].values[0]==1 & year>=Params["CreditPolicyStart"].values[0]:
        CreditPolicy2=Params["cp2"].values[0]
    return[Subsidy1,Subsidy2,CreditPolicy1,CreditPolicy2]
```

## Income and Power cost

This function generates the random incomes and electricity costs for each agent in every period. `Income_f` and `Powercost_f` are vectors of length *N*, where *N* is the number of agents in the model. The deterministic mean value of income and power cost for each agent is assumed to grow at rate `Trend` (which may be heterogeneous across agents) at each time step. We then draw the actual income and power cost for each agent in the current period using uniform draws which are then transformed into draws from a normal distribution with means `Income_f` and `Powercost_f` respectively and standard deviations `Income_sd` and `Powercost_sd` respectively. Both income and power cost are constrained to be positive for each agent.

If an agent owns PV (such that `PV[n]==1`), the amount it has to pay for electricity is reduced by the capacity of the panel times the current electricity price, including a subsidy if `Subsidy2>0` (see above). Finally, we also calculate `income_p`, a measure of income net of electricity cost for each agent.

```{python}
def IncomePowercost(Income_f,Trend,Powercost_f,Income_sd,Powercost_sd,PV,Price,Subsidy2,Params):
    #Means of distributions for income and electricity cost are increased by trend component
    Income_f=Income_f*(1+Trend)
    Powercost_f=Powercost_f*(1+Trend)
    #Draw uniform random numbers
    randincome=np.random.uniform(0,1,Income_f.size)
    randincome2=np.random.uniform(0,1,Income_f.size)
    randpowercost=np.random.uniform(0,1,Powercost_f.size)
    randpowercost2=np.random.uniform(0,1,Powercost_f.size)
    #Convert uniform to normal with the appropriate means and standard deviations
    randincome=np.sqrt(-2*np.log(randincome))*np.cos(2*np.pi*randincome2)
    randpowercost=np.sqrt(-2*np.log(randpowercost))*np.cos(2*np.pi*randpowercost2)
    randincome=Income_sd*randincome*Income_f+Income_f
    randincome=np.maximum(1e-10,randincome)
    randpowercost=Powercost_sd*randpowercost*Powercost_f+Powercost_f
    randpowercost=np.maximum(1e-10,randpowercost)
    #Reduce electricity cost of PV owners
    randpowercost=(randpowercost-PV*(1+Subsidy2)*Params["PVCapacity"].values[0])*Price
    #Calculate income net of electricity cost
    income_p=randincome-randpowercost
    #Return income, electricity cost, and income net of electricity cost
    return[randincome,randpowercost,income_p]
```

## Income Groups

The purpose of this function is to calculate income distribution statistics, as well as the rates of PV ownership by income decile, which are used in other parts of the model. We begin by sorting `Income_p`, the vector containing income net of electricity cost, in ascending order. Next, we set the cut-off points for income deciles and percentiles using the vectors `Positions_p` and `Positions_d`, which are calculated during the initialisation phase (described below) based on the number of agents in the model and give the number of agents in each decile/percentile. Next we iterate over all deciles and percentiles, assinging to each agent their income decile/percentile based on their current income net of electricity cost and, for deciles, also recording the number of decile members who have PV, which is in turn used to calculate PV ownership rates by income decile.

The function returns three vectors. `IncomePercentiles` and `IncomeDeciles` are vectors of length *N*, in which each element gives the income percentile/decile of the respective agent. `PVOwnershipDeciles` is a vector of length 10 which gives the PV ownership rates for each decile.

```{python}
def IncomeGroups(Income_p,PV,Positions_p,Percentiles,Positions_d,Deciles,IncomePercentiles,IncomeDeciles,PVOwnershipDeciles,DecileMembers):
    #Sort income net of electricity cost in ascending order
    income_psorted=np.sort(Income_p)
    #Based on sorted income and number of agents in each decile/percentile, set cut-off points
    Percentiles[0:99]=income_psorted[Positions_p]
    Percentiles[99]=income_psorted[((income_psorted.size)-1)]
    Deciles[0:9]=income_psorted[Positions_d]
    Deciles[9]=income_psorted[((income_psorted.size)-1)]
    #Initialise vectors to 0
    IncomeDeciles[:]=0
    IncomePercentiles[:]=0
    PVOwnershipDeciles[:]=0
    DecileMembers[:]=0
    #Iterate over deciles
    for i in range(10):
        #Determine which agents belong to decile i
        if i==0:
            members=np.where(Income_p<=Deciles[i])
        else:
            members=np.where((Income_p<=Deciles[i]) & (Income_p>Deciles[(i-1)]))
        #Set decile of all members to i
        IncomeDeciles[members]=i
        #Number of agents in decile i
        DecileMembers[i]=members[0].size
        #Number of PV owners in decile i
        PVOwnershipDeciles[i]=PV[members[0]].sum()
    #Iterate over percentiles
    for i in range(100):
        #Determine which agents belong to percentile i
        if i==0:
            members=np.where(Income_p<=Percentiles[i])
        else:
            members=np.where((Income_p<=Percentiles[i]) & (Income_p>Percentiles[(i-1)]))
        #Set percentile of all members to i
        IncomePercentiles[members]=i
    #Calculate PV ownership rates by decile
    PVOwnershipDeciles/=DecileMembers
    #Return vectors containing income decile/percentile of each agent and PV ownership rate by decile
    return[IncomePercentiles,IncomeDeciles,PVOwnershipDeciles]
```

## Consumption and saving

This function determines agents' consumption and saving. In addition, agents with positive outstanding debt make debt service payments. The main purpose of this is to update agents' `Liquidity` , i.e. their stock of liquid assets (money) which can be used to buy PV.

The function begins by setting a consumption propensity out of income net of electricity cost for each agent based on their current income percentile. From this, their desired consumption is determined, including a persistence component. Income, electricity cost and desired consumption are then used to calculate the desired saving of each agent. If an agent cannot finance their desired consumption and electricity cost using current income and accumulated liquid assets, their actual consumption is implicitly curtailed such that their liquidity does not become negative (since we assume that households cannot borrow for consumption but only to acquire PV).

Next, agents with positive debt make debt service payments, which are divided into principal payments (which reduce the stock of outstanding debt) and interest payments. Any interest payments which agents cannot afford are added to their balance of outstanding debt and their debt service payments for the following periods are updated accordingly. Agents whose debt has become zero in the current period (i.e. they have paid off their full loan) have their interest rate and debt service payments set to zero.

Finally, if an agent has positive saving after debt service in the current period, their liquidity is updated by a fraction of that increment. This fraction is based on the agent's current income decile and reflects the share of financial wealth held as liquid assets by income group.

The function returns agents' updated current liquidity, debt, debt service payments, loan interest rates and *desired* consumption (the latter is used in the next period to calculate the persistence component of desired consumption).

```{python}
def ConsumptionSaving(Income_p,Propensities,IncomePercentiles,Consumption,Income,Powercost,Liquidity,Debt,DebtService,LoanRate,PanelAge,LiquidityShares,Params,period):
    #Determine agents' consumption propensities out of income net of electricity cost based on their current income percentile
    consshares=Propensities[IncomePercentiles.astype(int)]
    #Determine agents' current desired consumption
    if period==0:
        Consumption[:]=consshares*Income_p
    else:
        #If simulation period>0, take into account persistence in desired consumption
        Consumption[:]=Params["PersistenceConsumption"].values[0]*Consumption[:]+(1-Params["PersistenceConsumption"].values[0])*consshares*Income_p
    #Agents' desired saving is Income (including electricity cost!) minus (desired) consumption minus electricity cost
    saving=Income-Consumption-Powercost
    #Save pre-consumption liquidity (stock of money) of each agent
    Liquidity_p=Liquidity
    #If liquidity and income are greater than consumption plus electricity cost, update liquidity using saving (which may be negative!)
    Liquidity[(Liquidity+Income)>=(Consumption+Powercost)]+=saving[(Liquidity+Income)>=(Consumption+Powercost)]
    #Otherwise, liquidity is set to 0; consumption is implicitly reduced to ensure liquidity does not become negative
    Liquidity[(Liquidity+Income)<(Consumption+Powercost)]=0
    #Determine debt service for agents with positive debt
    DebtService[Debt>0]=np.minimum(DebtService[Debt>0],Debt[Debt>0])
    #Decompose debt service into interest and principal component
    interest=LoanRate*Debt
    principal=DebtService-interest
    #Update remaining term of loan
    term=np.maximum(1,Params["PVMaxAge"].values[0]-PanelAge)
    #Principal is paid if agent can afford to do so; debt is reduced
    Debt[Liquidity>=DebtService]-=principal[Liquidity>=DebtService]
    #Agents who cannot afford full principal pay as much as they can
    Debt[(Liquidity>=interest) & (Liquidity<DebtService)]-=Liquidity[(Liquidity>=interest) & (Liquidity<DebtService)]
    #Any unpaid interest is added to outstanding debt
    Debt[Liquidity<interest]+=interest[Liquidity<interest]-Liquidity[Liquidity<interest]
    #Find agents who did not fully service debt
    adjustservice=np.where(Liquidity<DebtService)
    #Update liquidity based on debt service made
    Liquidity[Liquidity<DebtService]=0
    Liquidity[Liquidity>=DebtService]-=DebtService[Liquidity>=DebtService]
    #Adjust debt service of agents who did not pay full debt service
    DebtService[adjustservice]=Debt[adjustservice]*(LoanRate[adjustservice]*np.power((1+LoanRate[adjustservice]),term[adjustservice]))/(np.power((1+LoanRate[adjustservice]),term[adjustservice])-1)
    #Set loan rate, debt service and debt of agents who have paid off their loans to 0 (<=0) is used here since rounding errors can lead to slightly negative debt
    LoanRate[Debt<=0]=0
    DebtService[Debt<=0]=0
    Debt[Debt<=0]=0
    #Update liquidity based on shares of savings going into liquid assets by income percentile
    shares=LiquidityShares[IncomePercentiles.astype(int)]
    Liquidity[Liquidity>Liquidity_p]=Liquidity_p[Liquidity>Liquidity_p]+shares[Liquidity>Liquidity_p]*(Liquidity[Liquidity>Liquidity_p]-Liquidity_p[Liquidity>Liquidity_p])
    #Return agents' current liquidity, debt, debt service, loan rate and consumption
    return[Liquidity,Debt,DebtService,LoanRate,Consumption]
```

## Augment panel age

This short function augments the age of all solar panels in the model by one period. If the panel of an agent has reached its maximum age, the value of `PV` is set to zero for that agent, as is the value of `PanelAge`. The agent is then no longer a PV owner and will face the adoption decision again. The function returns the updated vectors of PV ownership and panel ages.

```{python}
def AugmentPanelAge(PV,PanelAge,Params):
    PanelAge[PV==1]+=1
    PV[PanelAge>Params["PVMaxAge"].values[0]]=0
    PanelAge[PanelAge>Params["PVMaxAge"].values[0]]=0
    return[PanelAge,PV]
```

## Expectations formation

This function is used to generate a time-series of expected future electricity prices for each agents. These are needed below when agents decide whether or not to adopt PV.

Expectations formation of our bounded rational agents takes place using the well-established recursive least squares algorithm. Each agent has their own "internal" AR(1) model of the electricity price, the coefficients of which they update in every period using the latest observation of the actual electricity price in the model. Importantly, each agent uses an individual gain parameter to update their estimations, such that expected electricity prices differ across agents. In particular, agents with a high gain parameter will tend to update their estimated coefficients more strongly in reaction to new information, while agents with a low gain parameter will react less.

The first part of the function updates the internal AR(1) models of the agents, while the second projects the models to generate time-series of a length equal to the maximum lifespan of a solar panel. The function then returns the coefficients variance-covariance matrices of the updated AR(1) models and the time-series of expected prices.

```{python}
def FormExpectation(ARPars,ARMats,Price,Gain,ExpectedPrice,period):
    #Generate vector of independent variables --> constant=1 and current change in price
    independent=np.array([[1],[(Price[(period+1)]-Price[period])]])
    #Update variance-covariance matrices following recursive least squares algorithm
    mat1=np.dot(independent,independent.transpose())
    ARMatsNew=ARMats+Gain[:,None,None]*(mat1-ARMats)
    #Test for singularity of updated matrices
    test=np.linalg.det(ARMatsNew)
    if(sum(test==0)>0):
        print('One or more matrices are singular!')
    #If updated matrix of an agent is singular, use old matrix
    ARMats[np.where(test!=0)]=ARMatsNew[np.where(test!=0)]
    #Update coefficient estimates of agents' AR(1) models
    transposes=ARPars.swapaxes(1,2)
    result1=np.dot(transposes,independent)
    dependent=Price[(period+2)]-Price[(period+1)]
    result1=dependent-result1
    result1=independent*result1
    result1=np.linalg.solve(ARMats,result1)
    ARPars+=Gain[:,None,None]*result1
    transposes1=ARPars[:,0].transpose()
    transposes2=ARPars[:,1].transpose()
    #Generate time-series of expected electricity price for each agent
    ExpectedPrice[:,0]=(Price[(period+2)]+ARPars[:,0]+ARPars[:,1]*(Price[(period+2)]-Price[(period+1)])).transpose()
    ExpectedPrice[:,1]=ExpectedPrice[:,0]+transposes1+transposes2*(ExpectedPrice[:,0]-Price[(period+2)])
    for t in range(2,len(ExpectedPrice[0])):
        ExpectedPrice[:,t]=ExpectedPrice[:,(t-1)]+transposes1+transposes2*(ExpectedPrice[:,(t-1)]-ExpectedPrice[:,(t-2)])
    #Return components of updated AR(1) models and the time-series of expected prices
    return[ARMats,ARPars,ExpectedPrice]
```

## Adoption Decision

In this function, agents who do not yet own PV decide whether or not to purchase a panel.

The function first checks which agents would need a loan in order to adopt PV (namely those who do not have sufficient liquid assets to buy one outright). Based on the size of the loan needed, agents may be credit rationed if the resulting loan to value ratio exceeds the maximum permitted level (note that in the current implementation, `Params["MaxLTV"]=1` such that this rationing mechanism is effectively switched off).

Next, the bank proposes a loan interest rate to every agent with positive borrowing needs based on the size of the required loan. From this, in turn, we calculate the size of the implied debt service payment. If the prospective debt service payment of an agent exceeds a certain fraction (`Params["MaxDTI"]`) of their current income, the agent is credit rationed. Since the model only includes a single type of solar panel with a given installation cost, credit rationed agents cannot adopt (i.e. they cannot, for instance, buy a smaller panel with a smaller loan).

The function then calculates, for each agent, a sum of expected discounted revenue from owning PV over the lifetime of a panel, based on agents' expected electricity prices, as well as a sum of discounted future loan costs based on the size of the needed loan and the interest rate proposed by the bank. From this, an expected profit from adopting PV is derived.

This expected profit, in turn, feeds into the expected utility from adopting PV. In addition to profit, this utility also contains a component related to social influence (based on the share of other agents in a given agent's income decile who have already adopted PV) and one related to environmental attitude.

Agents for whom expected utility is positive purchase a solar panel and their liquidity, debt, debt service payments and loan rates are updated accordingly. The function then returns the updated vectors of PV ownership, credit rationing, liquidity, loan rates, debt stocks and debt service payments.

```{python}
def AdoptionDecision(PV,Feasible,Liquidity,Rationed,Debt,Income,ExpectedPrice,Discount,Revenue,LoanCost,PVOwnershipDeciles,IncomeDeciles,LoanRate,DebtService,Influence,Attitude,Subsidy1,Subsidy2,CreditPolicy1,CreditPolicy2,Params):
    #Determine size of loan needed to purchase PV (installation cost minus stock of money held)
    loanneeded=(1-Subsidy1)*Params["PanelCost"].values[0]-Liquidity
    #Agents who already have PV do not need a loan
    loanneeded[PV==1]=0
    #Agents who have sufficient money to buy outright do not need a loan
    loanneeded[(PV==0) & (Liquidity>=((1-Subsidy1)*Params["PanelCost"].values[0]))]=0
    #Agents on whose dwelling PV is not feasible do not need a loan
    loanneeded[Feasible==0]=0
    #Check credit rationing condition based on loan to value ratio
    Rationed[(loanneeded+Debt)>((1-Subsidy1)*Params["PanelCost"].values[0]*(Params["MaxLTV"].values[0]+CreditPolicy1))]=1
    #Based on loan needed, calculate loan rate proposed by the bank
    proposedrate=Params["BaseRate"].values[0]+Params["InterestMarkup"].values[0]*(1+loanneeded/((1-Subsidy1)*Params["PanelCost"].values[0]*Params["MaxLTV"].values[0]))
    #Based on proposed rate, calculate implied debt service payment
    payment=loanneeded*(proposedrate*(np.power(1+proposedrate,Params["PVMaxAge"].values[0])))/((np.power(1+proposedrate,Params["PVMaxAge"].values[0]))-1)
    #Check credit rationing condition based on debt service to income ratio
    Rationed[(payment/Income)>(Params["MaxDTI"].values[0]+CreditPolicy2)]=1
    #Agents who do not need a loan, for whom PV is technically infeasible or who already have PV are not rationed
    Rationed[loanneeded==0]=0
    Rationed[Feasible==0]=0
    Rationed[PV==1]=0
    #Calculate the discounted sums of expected revenue from PV and loan cost for each agent using expected future electricity prices
    Revenue[:]=0
    LoanCost[:]=0
    balanceremaining=loanneeded
    for t in range(Params["PVMaxAge"].values[0]):
        Revenue+=ExpectedPrice[:,t]*(1+Subsidy2)*Params["PVCapacity"].values[0]/(np.power(1+Discount,t))
        cost=proposedrate*balanceremaining
        balanceremaining-=(payment-cost)
        LoanCost+=cost/(np.power(1+Discount,t))
    #Expected profit is expected discounted revenue minus installation cost minus discounted loan cost
    profit=Revenue-((1-Subsidy1)*Params["PanelCost"].values[0])-LoanCost
    #Get the rates of PV ownership in the income decile of each agent
    deciles=PVOwnershipDeciles[IncomeDeciles.astype(int)]
    #Calculate utility based on profit, social influence and environmental attitude
    utility=profit+Influence*(deciles-(1-deciles))+Params["Beta"].values[0]*Attitude
    #Utility for agents who are credit rationed, for whom PV is technically infeasible, or who already own PV is zero
    utility[Rationed==1]=0
    utility[Feasible==0]=0
    utility[PV==1]=0
    #Agents with positive utility adopt
    adopters=np.where(utility>0)
    #Adopters who need a loan are borrowers
    borrowers=np.where((utility>0) & (loanneeded>0))
    PV[adopters]=1
    #Calculate updated liquidity, loan rates, debt and debt service payments of adopters/borrowers
    Liquidity[adopters]-=((1-Subsidy1)*Params["PanelCost"].values[0])+loanneeded[adopters]
    LoanRate[borrowers]=proposedrate[borrowers]*loanneeded[borrowers]/(loanneeded[borrowers]+Debt[borrowers])+LoanRate[borrowers]*Debt[borrowers]/(loanneeded[borrowers]+Debt[borrowers])
    Debt[borrowers]+=loanneeded[borrowers]
    DebtService[borrowers]=Debt[borrowers]*(LoanRate[borrowers]*(np.power(1+LoanRate[borrowers],Params["PVMaxAge"].values[0])))/((np.power(1+LoanRate[borrowers],Params["PVMaxAge"].values[0]))-1)
    #Return vectors of PV ownership, credit rationing, liquidity, loan rates, debt stocks and debt service payments
    return[PV,Rationed,Liquidity,LoanRate,Debt,DebtService]
```

## Calculate statistics

This function calculates a range of statistics, time-series of which will be returned by the main function at the end of a simulation.

```{python}
def CalculateStatistics(PV,Income,Debt,Liquidity,ExpectedPrice,Feasible,Rationed):
    #Average income
    averageincome=np.sum(Income)/Income.size
    #Average liquidity
    averageliquidity=np.sum(Liquidity)/Liquidity.size
    #Average expected electricity price in the next period
    averageexpectedprice=np.sum(ExpectedPrice)/ExpectedPrice.size
    #Average debt, counting only agents with positive debt
    averagedebt=np.sum(Debt[Debt>0])/np.sum(Debt>0)
    #Number of PV owners as % of all agents
    adoptionrate1=np.sum(PV)/PV.size
    #Number of PV owners as % of agents for whom PV is technically feasible
    adoptionrate2=np.sum(PV)/np.sum(Feasible)
    #Share of agents who could adopt PV but are prevented by credit rationing
    rationing=np.sum(Rationed)/np.sum((PV==0) & (Feasible==1))
    return(averageincome,averageliquidity,averageexpectedprice,averagedebt,adoptionrate1,adoptionrate2,rationing)
```

## Main model function

This is the function which must be called to execute the model. It takes several inputs, namely:

::: incremental
-   `inputfile` - a csv file containing a a list of all model households and their initial characteristics
-   `propensitiesfile` - a csv file containing propensities to consume out of income by income percentile
-   `liquiditysharesfile` - a csv file containing the shares of saving going into liquid assets by income percentile
-   `paramfile` - a csv file containing the names and values of all model parameters
-   `seed` - a seed for the pseudo-random number generator
-   `start` - the start year of the model simulation
-   `end` - the end year of the model simulation
:::

The function begins by setting the seed for the pseudo-random number generator, and then loads all necessary external input files. It then initialises the model by generating vectors/arrays of all model variables and setting initial values where necessary.

Subsequently, there is a single call to `GenerateElectricityPrice` in order to generate a time-series of electricity prices for the current model run. After this, the main simulation loop is entered. In each simulation period, the model calls the functions described above one after the other, updating the relevant model variables based on the outputs of each function.

At the end of the simulation run, the time-series of aggregate statistics to be returned are stacked into a single array and converted to a dataframe, which is then saved in csv format, with the seed number attached to the file name.

```{python}
def PVModel(inputfile="inputs.csv",propensitiesfile="consumptionpropensities.csv",liquiditysharesfile="liquidityshares.csv",paramfile="parameters.csv",seed=1,start=2018,end=2040):
    #Set seed
    np.random.seed(seed)
    
    #Load external input files
    Inputs=pd.read_csv(inputfile)
    Params=pd.read_csv(paramfile)
    Propensities=np.ndarray.flatten(pd.read_csv(propensitiesfile,header=None).to_numpy())
    LiquidityShares=np.ndarray.flatten(pd.read_csv(liquiditysharesfile,header=None).to_numpy())

    #Initial means of income for random draws are taken from input file
    Income_f=np.ndarray.flatten(Inputs[["income"]].to_numpy())
    #Generate arrays of zeros to hold actual incomes and actual incomes net of electricity cost --> note that len(Inputs.index) gives the number of individual agents
    Income=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    Income_p=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Standard deviations of incomes for random draws are taken from input file
    Income_sd=np.ndarray.flatten(Inputs[["incomesd"]].to_numpy())
    #Initial means of electricity cost for random draws are taken from input file
    Powercost_f=np.ndarray.flatten(Inputs[["powercons"]].to_numpy())
    #Standard deviations of electricity cost for random draws are taken from input file
    Powercost_sd=np.ndarray.flatten(Inputs[["powerconssd"]].to_numpy())
    #Generate arrays of zeros to hold actual electricity cost 
    Powercost=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Generate array of zeros to hold current desired consumption
    Consumption=np.zeros(len(Inputs.index))
    #Generate array of zeros to hold agents' liquid assets
    Liquidity=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Initial liquid assets are taken from input file
    Liquidity[:,0]=np.ndarray.flatten(Inputs[["liquidity"]].to_numpy())
    #Generate arrays of zeros to hold agents' debt, debt service and loan rates
    Debt=np.zeros(len(Inputs.index))
    DebtService=np.zeros(len(Inputs.index))
    LoanRate=np.zeros(len(Inputs.index))

    #Trend growth rates of mean incomes and electricity costs are taken from input file
    Trend=np.ndarray.flatten(Inputs[["trend"]].to_numpy())
    #Dummies indicating whether agents live in a house(=1) or a flat (=0) are taken from input file
    House=np.ndarray.flatten(Inputs[["house"]].to_numpy())
    #Generate array of zeros to hold agents' PV ownership status over time
    PV=np.zeros(shape=(len(Inputs.index),(end-start+1)))
    #Initial PV ownership status is taken from input file
    PV[:,0]=np.ndarray.flatten(Inputs[["pv"]].to_numpy())
    #Initial solar panel age is taken from input file
    PanelAge=np.ndarray.flatten(Inputs[["panelage"]].to_numpy())
    #Environmental attitude is taken from input file
    Attitude=np.ndarray.flatten(Inputs[["attitude"]].to_numpy())
    #The degree to which each agent is subject to social influence is given by a draw from a uniform distribution; upper and lower bounds are taken from parameter file.
    Influence=np.random.uniform(0,1,len(Inputs.index))*(Params["MaxInfluence"].values[0]-Params["MinInfluence"].values[0])+Params["MinInfluence"].values[0]
    #The individual discount rates of agents are given by draws from a uniform distribution; upper and lower bounds are taken from parameter file.
    Discount=np.random.uniform(0,1,len(Inputs.index))*(Params["MaxDiscount"].values[0]-Params["MinDiscount"].values[0])+Params["MinDiscount"].values[0]
    #Generate vector of zeros to hold dummies indicating whether PV is technically feasible on the dwelling of an agent
    Feasible=np.zeros(len(Inputs.index))
    #Feasibility is set to 1 for agents already owning PV
    Feasible[PV[:,0]==1]=1
    #Feasibility is set to 1 for agents living in a house
    Feasible[House==1]=1
    #Feasibility is set to 1 with a certain probability for all other agents
    Feasible[(House==0) & (PV[:,0]==0)]=np.random.uniform(0,1,sum((House==0) & (PV[:,0]==0)))
    Feasible[Feasible>=(1-Params["FeasibilityProb"].values[0])]=1
    Feasible[Feasible<(1-Params["FeasibilityProb"].values[0])]=0

    #Based on the number of agents in the model, set the indices delimiting each income percentile
    Positions_p=np.zeros(99)
    Positions_p[:]=np.array(range(1,100,1))*(len(Inputs.index)+1)/100-1
    Positions_p=np.round(Positions_p)
    Positions_p=Positions_p.astype(int)
    #Generate a vector of zeros to hold the income cut-offs corresponding to each percentile
    Percentiles=np.zeros(100)
    #Based on the number of agents in the model, set the indices delimiting each income decile
    Positions_d=np.zeros(9)
    Positions_d[:]=np.array(range(1,10,1))*(len(Inputs.index)+1)/10-1
    Positions_d=np.round(Positions_d)
    Positions_d=Positions_d.astype(int)
    #Generate a vector of zeros to hold the income cut-offs corresponding to each decile
    Deciles=np.zeros(10)
    #Generate a vector of zeros to hold the number of agents in each decile
    DecileMembers=np.zeros(10)
    #Generate a vector of zeros to hold the share of agents owning PV in each income decile
    PVOwnershipDeciles=np.zeros(10)
    #Generate vectors of zeros to hold the current income decile/percentile of each agent
    IncomeDeciles=np.zeros(len(Inputs.index))
    IncomePercentiles=np.zeros(len(Inputs.index))

    #The individual gain parameter used by each agent during expectations formation is given by a draw from a uniform distribution; upper and lower bounds are taken from parameter file.
    Gain=np.random.uniform(0,1,len(Inputs.index))*(Params["MaxGain"].values[0]-Params["MinGain"].values[0])+Params["MinGain"].values[0]
    #Initialise the coefficients of agents' internal AR(1) models to those governing the true AR(1) process
    ARPars=np.array([[Params["ElectricityPriceTrend"].values[0]],[Params["ElectricityPriceAR"].values[0]]])
    ARPars=[ARPars]*len(Inputs.index)
    ARPars=np.array(ARPars)
    #Initialise the variance-covariance matrices of agents' internal AR(1) models to those from the true AR(1) process
    ARMats=np.array([[Params["ElectricityPriceMat11"].values[0],Params["ElectricityPriceMat12"].values[0]],[Params["ElectricityPriceMat21"].values[0],Params["ElectricityPriceMat22"].values[0]]])
    ARMats=[ARMats]*len(Inputs.index)
    ARMats=np.array(ARMats)
    #Generate an array of zeros to hold the time-series of agents' expected electricity prices
    ExpectedPrice=np.zeros(shape=(len(Inputs.index),Params["PVMaxAge"].values[0]))

    #Generate arrays of zeros to hold sums of expected discounted revenue from owning PV, loan costs, and dummies indicating whether agents are credit rationed
    Revenue=np.zeros(len(Inputs.index))
    LoanCost=np.zeros(len(Inputs.index))
    Rationed=np.zeros(len(Inputs.index))

    #Initialise policy variables
    Subsidy1=0
    Subsidy2=0
    CreditPolicy1=0
    CreditPolicy2=0

    #Generate arrays of zeros to hold aggregate statistics which will be saved after the run
    AverageIncome=np.zeros((end-start+1))
    AverageLiquidity=np.zeros((end-start+1))
    AverageExpectedPrice=np.zeros((end-start+1))
    AverageDebt=np.zeros((end-start+1))
    AdoptionRate1=np.zeros((end-start+1))
    AdoptionRate2=np.zeros((end-start+1))
    ChangeAdoptionRate1=np.zeros((end-start+1))
    ChangeAdoptionRate2=np.zeros((end-start+1))
    RationedShare=np.zeros((end-start+1))

    #Generate electricity price time-series for the current run
    Price=GenerateElectricityPrice(Params=Params,length=(end-start+3))
    #Enter main model loop
    year=start
    for period in range((end-start+1)):
        #Set starting values for liquid assets and PV equal to closing values from last period
        if period>0:
            Liquidity[:,period]=Liquidity[:,(period-1)]
            PV[:,period]=PV[:,(period-1)]
        #Set policy variables
        PolicyReturn=SetPolicy(Subsidy1=Subsidy1,Subsidy2=Subsidy2,CreditPolicy1=CreditPolicy1,CreditPolicy2=CreditPolicy2,year=year,Params=Params)
        Subsidy1=PolicyReturn[0]
        Subsidy2=PolicyReturn[1]
        CreditPolicy1=PolicyReturn[2]
        CreditPolicy2=PolicyReturn[3]
        #Calculate income and electricity cost
        IncomePowercostReturn=IncomePowercost(Income_f=Income_f,Trend=Trend,Powercost_f=Powercost_f,Income_sd=Income_sd,Powercost_sd=Powercost_sd,PV=PV[:,period],Price=Price[(period+2)],Subsidy2=Subsidy2,Params=Params)
        Income[:,period]=IncomePowercostReturn[0]
        Powercost[:,period]=IncomePowercostReturn[1]
        Income_p[:,period]=IncomePowercostReturn[2]
        #Calculate income distribution statistics and PV ownership by decile
        IncomeGroupReturn=IncomeGroups(Income_p=Income_p[:,period],PV=PV[:,period],Positions_p=Positions_p,Percentiles=Percentiles,Positions_d=Positions_d,Deciles=Deciles,IncomePercentiles=IncomePercentiles,IncomeDeciles=IncomeDeciles,PVOwnershipDeciles=PVOwnershipDeciles,DecileMembers=DecileMembers)
        IncomePercentiles[:]=IncomeGroupReturn[0]
        IncomeDeciles[:]=IncomeGroupReturn[1]
        PVOwnershipDeciles[:]=IncomeGroupReturn[2]
        #Calculate consumption, saving and debt service; update liquidity
        ConsumptionSavingReturn=ConsumptionSaving(Income_p=Income_p[:,period],Propensities=Propensities,IncomePercentiles=IncomePercentiles,Consumption=Consumption,Income=Income[:,period],Powercost=Powercost[:,period],Liquidity=Liquidity[:,period],Debt=Debt,DebtService=DebtService,LoanRate=LoanRate,PanelAge=PanelAge,LiquidityShares=LiquidityShares,Params=Params,period=period)
        Liquidity[:,period]=ConsumptionSavingReturn[0]
        Debt[:]=ConsumptionSavingReturn[1]
        DebtService[:]=ConsumptionSavingReturn[2]
        LoanRate[:]=ConsumptionSavingReturn[3]
        Consumption[:]=ConsumptionSavingReturn[4]
        #Increment age of existing panels; reset PV ownership if a panel reaches maximum age
        PanelAgeReturn=AugmentPanelAge(PV=PV[:,period],PanelAge=PanelAge,Params=Params)
        PanelAge=PanelAgeReturn[0]
        PV[:,period]=PanelAgeReturn[1]
        #Form expectations of future electricity price
        ExpectationReturn=FormExpectation(ARPars=ARPars,ARMats=ARMats,Price=Price,Gain=Gain,ExpectedPrice=ExpectedPrice,period=period)
        ARMats=ExpectationReturn[0]
        ARPars=ExpectationReturn[1]
        ExpectedPrice=ExpectationReturn[2]
        #Adoption decision; update liquidity, debt, PV ownership etc.
        AdoptionReturn=AdoptionDecision(PV=PV[:,period],Feasible=Feasible,Liquidity=Liquidity[:,period],Rationed=Rationed,Debt=Debt,Income=Income[:,period],ExpectedPrice=ExpectedPrice,Discount=Discount,Revenue=Revenue,LoanCost=LoanCost,PVOwnershipDeciles=PVOwnershipDeciles,IncomeDeciles=IncomeDeciles,LoanRate=LoanRate,DebtService=DebtService,Influence=Influence,Attitude=Attitude,Subsidy1=Subsidy1,Subsidy2=Subsidy2,CreditPolicy1=CreditPolicy1,CreditPolicy2=CreditPolicy2,Params=Params)
        PV[:,period]=AdoptionReturn[0]
        Rationed[:]=AdoptionReturn[1]
        Liquidity[:,period]=AdoptionReturn[2]
        LoanRate[:]=AdoptionReturn[3]
        Debt[:]=AdoptionReturn[4]
        DebtService[:]=AdoptionReturn[5]
        #Calculate aggregate statistics
        StatisticsReturn=CalculateStatistics(PV=PV[:,period],Income=Income[:,period],Debt=Debt,Liquidity=Liquidity[:,period],ExpectedPrice=ExpectedPrice[:,0],Feasible=Feasible,Rationed=Rationed)
        AverageIncome[period]=StatisticsReturn[0]
        AverageLiquidity[period]=StatisticsReturn[1]
        AverageExpectedPrice[period]=StatisticsReturn[2]
        AverageDebt[period]=StatisticsReturn[3]
        AdoptionRate1[period]=StatisticsReturn[4]
        AdoptionRate2[period]=StatisticsReturn[5]
        RationedShare[period]=StatisticsReturn[6]
        if period>0:
            ChangeAdoptionRate1[period]=AdoptionRate1[period]-AdoptionRate1[(period-1)]
            ChangeAdoptionRate2[period]=AdoptionRate2[period]-AdoptionRate2[(period-1)]
        #Increment year
        year+=1

    #Save time-series of aggregate statistics as csv
    Stats=np.column_stack((AverageIncome,AverageLiquidity,AverageExpectedPrice,AverageDebt,AdoptionRate1,AdoptionRate2,ChangeAdoptionRate1,ChangeAdoptionRate2,RationedShare,Price[2:len(Price)]))
    Stats=pd.DataFrame(data=Stats,columns=["AverageIncome","AverageLiquidity","AverageExpectedPrice","AverageDebt","AdoptionRate1","AdoptionRate2","ChangeAdoptionRate1","ChangeAdoptionRate2","RationedShare","Price"])
    filename='out_'
    filename+=str(seed)
    filename+='.csv'
    Stats.to_csv(filename)
```

## 
